---
title: "Records"
description: "Create immutable data types with built-in equality and more"
order: 3
difficulty: "intermediate"
tags: ["records", "immutable", "with expressions", "value equality"]
duration: "25 minutes"
---

# Records

Records are a powerful feature introduced in C# 9 that provide a concise syntax for creating immutable data types with built-in value equality, deconstruction, and more.

## Basic Record Syntax

<CodeEditor 
  initialCode={`using System;

// Record declaration - most concise form
record Person(string FirstName, string LastName, int Age);

// Equivalent to a class with:
// - Properties: FirstName, LastName, Age
// - Constructor with all properties
// - Value equality
// - ToString() override
// - Deconstruction support

class Program
{
    static void Main()
    {
        // Create record instances
        var person1 = new Person("John", "Doe", 30);
        var person2 = new Person("Jane", "Smith", 25);
        var person3 = new Person("John", "Doe", 30);
        
        // ToString is automatically generated
        Console.WriteLine("People:");
        Console.WriteLine($"  {person1}");
        Console.WriteLine($"  {person2}");
        Console.WriteLine($"  {person3}");
        
        // Value equality (not reference equality)
        Console.WriteLine("\\nEquality Checks:");
        Console.WriteLine($"  person1 == person3: {person1 == person3}");  // True!
        Console.WriteLine($"  person1 == person2: {person1 == person2}");  // False
        Console.WriteLine($"  ReferenceEquals: {ReferenceEquals(person1, person3)}");  // False
    }
}`}
/>

## Value Equality vs Reference Equality

<CodeEditor 
  initialCode={`using System;

// Record with value equality
record Product(string Name, decimal Price);

// Class with reference equality
class ProductClass
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    
    public ProductClass(string name, decimal price)
    {
        Name = name;
        Price = price;
    }
}

class Program
{
    static void Main()
    {
        // Records - value equality
        var record1 = new Product("Laptop", 999.99m);
        var record2 = new Product("Laptop", 999.99m);
        
        Console.WriteLine("=== RECORDS (Value Equality) ===");
        Console.WriteLine($"record1: {record1}");
        Console.WriteLine($"record2: {record2}");
        Console.WriteLine($"record1 == record2: {record1 == record2}");  // True
        Console.WriteLine($"record1.Equals(record2): {record1.Equals(record2)}");  // True
        Console.WriteLine($"Same reference?: {ReferenceEquals(record1, record2)}");  // False
        
        // Classes - reference equality
        var class1 = new ProductClass("Laptop", 999.99m);
        var class2 = new ProductClass("Laptop", 999.99m);
        
        Console.WriteLine("\\n=== CLASSES (Reference Equality) ===");
        Console.WriteLine($"class1: {class1.Name}, {class1.Price}");
        Console.WriteLine($"class2: {class2.Name}, {class2.Price}");
        Console.WriteLine($"class1 == class2: {class1 == class2}");  // False!
        Console.WriteLine($"class1.Equals(class2): {class1.Equals(class2)}");  // False!
        Console.WriteLine($"Same reference?: {ReferenceEquals(class1, class2)}");  // False
    }
}`}
/>

## With Expressions - Non-Destructive Mutation

<CodeEditor 
  initialCode={`using System;

record Person(string FirstName, string LastName, int Age);

record Address(string Street, string City, string Country);

record Employee(string Name, string Department, decimal Salary, Address Address);

class Program
{
    static void Main()
    {
        // Original record
        var original = new Person("John", "Doe", 30);
        Console.WriteLine($"Original: {original}");
        
        // Create copy with one property changed
        var older = original with { Age = 31 };
        Console.WriteLine($"After birthday: {older}");
        
        // Original is unchanged (immutable)
        Console.WriteLine($"Original still: {original}");
        
        // Change multiple properties
        var married = original with { LastName = "Smith", Age = 31 };
        Console.WriteLine($"Married: {married}");
        
        Console.WriteLine("\\n=== Nested Records ===");
        
        // Nested record example
        var address = new Address("123 Main St", "New York", "USA");
        var employee = new Employee("Alice", "Engineering", 75000m, address);
        Console.WriteLine($"Employee: {employee}");
        
        // Change salary
        var promoted = employee with { Salary = 85000m };
        Console.WriteLine($"Promoted: {promoted}");
        
        // Change nested property (need to create new Address)
        var relocated = employee with 
        { 
            Address = employee.Address with { City = "Los Angeles" } 
        };
        Console.WriteLine($"Relocated: {relocated}");
    }
}`}
/>

## Record Types: record vs record class vs record struct

<CodeEditor 
  initialCode={`using System;

// record (same as record class) - reference type
record PersonRecord(string Name, int Age);

// record struct (C# 10+) - value type
record struct Point(int X, int Y);

// readonly record struct - immutable value type
readonly record struct ImmutablePoint(int X, int Y);

class Program
{
    static void Main()
    {
        // Record class - reference type
        var person1 = new PersonRecord("John", 30);
        var person2 = person1;
        Console.WriteLine("=== record class (reference type) ===");
        Console.WriteLine($"Same reference: {ReferenceEquals(person1, person2)}");  // True
        Console.WriteLine($"Value equal: {person1 == person2}");  // True
        
        // Record struct - value type
        var point1 = new Point(10, 20);
        var point2 = point1;  // Creates a copy
        Console.WriteLine("\\n=== record struct (value type) ===");
        Console.WriteLine($"point1: {point1}");
        Console.WriteLine($"point2: {point2}");
        Console.WriteLine($"Value equal: {point1 == point2}");  // True
        
        // Record struct is mutable by default
        point2.X = 100;  // Modifies the copy
        Console.WriteLine($"After modifying point2.X:");
        Console.WriteLine($"point1: {point1}");  // Unchanged
        Console.WriteLine($"point2: {point2}");  // Changed
        
        // Readonly record struct is immutable
        var immutablePoint = new ImmutablePoint(5, 5);
        // immutablePoint.X = 10;  // Error! Cannot modify
        Console.WriteLine($"\\n=== readonly record struct ===");
        Console.WriteLine($"Immutable point: {immutablePoint}");
        
        var movedPoint = immutablePoint with { X = 15 };
        Console.WriteLine($"Moved point: {movedPoint}");
    }
}`}
/>

## Deconstruction

<CodeEditor 
  initialCode={`using System;

record Person(string FirstName, string LastName, int Age);

record Rectangle(int Width, int Height)
{
    public int Area => Width * Height;
    public int Perimeter => 2 * (Width + Height);
}

class Program
{
    static void Main()
    {
        var person = new Person("John", "Doe", 30);
        
        // Deconstruct into individual variables
        var (first, last, age) = person;
        Console.WriteLine($"Deconstructed: {first} {last}, age {age}");
        
        // Use in tuple pattern
        var people = new[]
        {
            new Person("Alice", "Smith", 25),
            new Person("Bob", "Jones", 35),
            new Person("Charlie", "Brown", 45)
        };
        
        Console.WriteLine("\\nPeople by age group:");
        foreach (var (firstName, lastName, personAge) in people)
        {
            string group = personAge switch
            {
                < 30 => "Young",
                < 40 => "Middle",
                _ => "Senior"
            };
            Console.WriteLine($"  {firstName} {lastName}: {group}");
        }
        
        // Works great with LINQ
        var rect = new Rectangle(10, 5);
        var (w, h) = rect;
        Console.WriteLine($"\\nRectangle: {w}x{h}");
        Console.WriteLine($"Area: {rect.Area}");
        Console.WriteLine($"Perimeter: {rect.Perimeter}");
    }
}`}
/>

## Adding Behavior to Records

<CodeEditor 
  initialCode={`using System;

record Temperature(double Celsius)
{
    // Computed property
    public double Fahrenheit => Celsius * 9 / 5 + 32;
    public double Kelvin => Celsius + 273.15;
    
    // Methods
    public bool IsFreezing => Celsius <= 0;
    public bool IsBoiling => Celsius >= 100;
    
    public string GetDescription()
    {
        return Celsius switch
        {
            < 0 => "Freezing",
            < 10 => "Cold",
            < 20 => "Cool",
            < 30 => "Warm",
            < 40 => "Hot",
            _ => "Extreme"
        };
    }
    
    // Static factory methods
    public static Temperature FromFahrenheit(double f) => 
        new Temperature((f - 32) * 5 / 9);
    
    public static Temperature FromKelvin(double k) => 
        new Temperature(k - 273.15);
}

class Program
{
    static void Main()
    {
        var temp1 = new Temperature(25);
        Console.WriteLine($"Temperature: {temp1}");
        Console.WriteLine($"  Fahrenheit: {temp1.Fahrenheit:F1}°F");
        Console.WriteLine($"  Kelvin: {temp1.Kelvin:F1}K");
        Console.WriteLine($"  Description: {temp1.GetDescription()}");
        Console.WriteLine($"  Is Freezing: {temp1.IsFreezing}");
        
        // Use factory methods
        var temp2 = Temperature.FromFahrenheit(32);
        Console.WriteLine($"\\nFrom 32°F: {temp2}");
        Console.WriteLine($"  Is Freezing: {temp2.IsFreezing}");
        
        var temp3 = Temperature.FromKelvin(373.15);
        Console.WriteLine($"\\nFrom 373.15K: {temp3}");
        Console.WriteLine($"  Is Boiling: {temp3.IsBoiling}");
    }
}`}
/>

## Inheritance with Records

<CodeEditor 
  initialCode={`using System;

// Base record
abstract record Shape(string Color);

// Derived records
record Circle(string Color, double Radius) : Shape(Color)
{
    public double Area => Math.PI * Radius * Radius;
    public double Circumference => 2 * Math.PI * Radius;
}

record Rectangle(string Color, double Width, double Height) : Shape(Color)
{
    public double Area => Width * Height;
    public double Perimeter => 2 * (Width + Height);
}

class Program
{
    static void Main()
    {
        Shape[] shapes = {
            new Circle("Red", 5),
            new Rectangle("Blue", 10, 5),
            new Circle("Green", 3)
        };
        
        Console.WriteLine("Shapes:");
        foreach (var shape in shapes)
        {
            Console.WriteLine($"  {shape}");
            
            // Pattern matching with records
            var info = shape switch
            {
                Circle c => $"    Circle area: {c.Area:F2}",
                Rectangle r => $"    Rectangle area: {r.Area:F2}",
                _ => "    Unknown shape"
            };
            Console.WriteLine(info);
        }
        
        // With expression preserves derived type
        var circle = new Circle("Red", 5);
        var biggerCircle = circle with { Radius = 10 };
        Console.WriteLine($"\\nOriginal: {circle}");
        Console.WriteLine($"Bigger: {biggerCircle}");
        
        // Equality works across inheritance
        var circle1 = new Circle("Blue", 3);
        var circle2 = new Circle("Blue", 3);
        Console.WriteLine($"\\ncircle1 == circle2: {circle1 == circle2}");  // True
    }
}`}
/>

## Records as DTOs (Data Transfer Objects)

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

// API Response records
record ApiResponse<T>(bool Success, string Message, T Data);

record UserDto(int Id, string Username, string Email, DateTime CreatedAt);

record OrderDto(
    int OrderId, 
    int UserId, 
    List<OrderItemDto> Items, 
    decimal Total,
    DateTime OrderDate
);

record OrderItemDto(int ProductId, string ProductName, int Quantity, decimal Price);

class Program
{
    static void Main()
    {
        // Simulate API responses
        var user = new UserDto(1, "john_doe", "john@example.com", DateTime.Now);
        var userResponse = new ApiResponse<UserDto>(true, "User found", user);
        
        Console.WriteLine("=== User API Response ===");
        Console.WriteLine($"Success: {userResponse.Success}");
        Console.WriteLine($"Message: {userResponse.Message}");
        Console.WriteLine($"Data: {userResponse.Data}");
        
        // Order with items
        var items = new List<OrderItemDto>
        {
            new OrderItemDto(1, "Laptop", 1, 999.99m),
            new OrderItemDto(2, "Mouse", 2, 29.99m),
            new OrderItemDto(3, "Keyboard", 1, 79.99m)
        };
        
        var order = new OrderDto(
            OrderId: 1001,
            UserId: 1,
            Items: items,
            Total: items.Sum(i => i.Price * i.Quantity),
            OrderDate: DateTime.Now
        );
        
        var orderResponse = new ApiResponse<OrderDto>(true, "Order retrieved", order);
        
        Console.WriteLine("\\n=== Order API Response ===");
        Console.WriteLine($"Order ID: {orderResponse.Data.OrderId}");
        Console.WriteLine($"Total: ${'{'}orderResponse.Data.Total:F2{'}'}");
        Console.WriteLine("Items:");
        foreach (var item in orderResponse.Data.Items)
        {
            Console.WriteLine($"  - {item.ProductName} x{item.Quantity}: ${'{'}item.Price * item.Quantity:F2{'}'}");
        }
    }
}`}
/>

## Records in Collections

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;
using System.Linq;

record Product(string Name, string Category, decimal Price);

class Program
{
    static void Main()
    {
        var products = new List<Product>
        {
            new Product("Laptop", "Electronics", 999.99m),
            new Product("Phone", "Electronics", 699.99m),
            new Product("Tablet", "Electronics", 499.99m),
            new Product("Desk", "Furniture", 299.99m),
            new Product("Chair", "Furniture", 199.99m),
            new Product("Laptop", "Electronics", 999.99m)  // Duplicate
        };
        
        Console.WriteLine("All products:");
        products.ForEach(p => Console.WriteLine($"  {p}"));
        
        // Distinct works with value equality
        var uniqueProducts = products.Distinct().ToList();
        Console.WriteLine($"\\nUnique products ({uniqueProducts.Count}):");
        uniqueProducts.ForEach(p => Console.WriteLine($"  {p}"));
        
        // HashSet with records
        var productSet = new HashSet<Product>(products);
        Console.WriteLine($"\\nHashSet count: {productSet.Count}");
        
        // Contains works correctly
        var searchProduct = new Product("Phone", "Electronics", 699.99m);
        Console.WriteLine($"Contains Phone: {productSet.Contains(searchProduct)}");
        
        // GroupBy
        Console.WriteLine("\\nProducts by category:");
        var byCategory = products.GroupBy(p => p.Category);
        foreach (var group in byCategory)
        {
            Console.WriteLine($"  {group.Key}:");
            foreach (var product in group)
            {
                Console.WriteLine($"    {product.Name}: ${'{'}product.Price{'}'}");
            }
        }
        
        // Dictionary with records as keys
        var inventory = new Dictionary<Product, int>
        {
            [new Product("Laptop", "Electronics", 999.99m)] = 50,
            [new Product("Phone", "Electronics", 699.99m)] = 100
        };
        
        var lookupKey = new Product("Laptop", "Electronics", 999.99m);
        Console.WriteLine($"\\nLaptop inventory: {inventory[lookupKey]}");
    }
}`}
/>

## Key Takeaways

- **Records** provide immutable data types with minimal boilerplate
- **Value equality** is built-in (unlike classes)
- **With expressions** enable non-destructive mutation
- **Deconstruction** allows easy property extraction
- **record class** (reference type) vs **record struct** (value type)
- **Inheritance** works with records
- Perfect for **DTOs**, **domain models**, and **configuration objects**

## When to Use Records

| Use Records When | Use Classes When |
|------------------|------------------|
| Data should be immutable | Data needs to be mutable |
| Value equality is needed | Identity equality is needed |
| Creating DTOs or value objects | Complex behavior is primary |
| Using pattern matching | Entity objects with changing state |

## Best Practices

1. **Prefer immutability** - use records for data that shouldn't change
2. **Use with expressions** instead of mutation
3. **Consider record struct** for small, frequently created data
4. **Use positional syntax** for simple records
5. **Add behavior sparingly** - records are primarily for data

## Next Module

Congratulations! You've completed the Modern C# module. Continue to **Data Structures** to learn about arrays, collections, and dictionaries!
