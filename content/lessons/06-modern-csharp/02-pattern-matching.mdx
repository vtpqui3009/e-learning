---
title: "Pattern Matching"
description: "Use powerful pattern matching for cleaner conditional logic"
order: 2
difficulty: "advanced"
tags: ["pattern matching", "switch expression", "is", "when"]
duration: "30 minutes"
---

# Pattern Matching

Pattern matching is a powerful feature that enables concise, expressive code for conditional logic. It extends traditional switch statements with type patterns, property patterns, and more.

## Type Patterns with 'is'

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        object[] items = { 42, "Hello", 3.14, true, null, new int[] {1, 2, 3} };
        
        foreach (var item in items)
        {
            // Type pattern with 'is'
            if (item is int number)
            {
                Console.WriteLine($"Integer: {number * 2}");
            }
            else if (item is string text)
            {
                Console.WriteLine($"String: {text.ToUpper()}");
            }
            else if (item is double d)
            {
                Console.WriteLine($"Double: {d:F2}");
            }
            else if (item is bool flag)
            {
                Console.WriteLine($"Boolean: {flag}");
            }
            else if (item is int[] arr)
            {
                Console.WriteLine($"Array: [{string.Join(", ", arr)}]");
            }
            else if (item is null)
            {
                Console.WriteLine("Null value");
            }
        }
    }
}`}
/>

## Switch Expressions (C# 8+)

A more concise alternative to switch statements:

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Traditional switch statement vs switch expression
        
        // Example 1: Day of week
        int day = 3;
        string dayName = day switch
        {
            1 => "Monday",
            2 => "Tuesday",
            3 => "Wednesday",
            4 => "Thursday",
            5 => "Friday",
            6 => "Saturday",
            7 => "Sunday",
            _ => "Invalid day"  // Default case
        };
        Console.WriteLine($"Day {day} is {dayName}");
        
        // Example 2: Grade letter
        int score = 85;
        string grade = score switch
        {
            >= 90 => "A",
            >= 80 => "B",
            >= 70 => "C",
            >= 60 => "D",
            _ => "F"
        };
        Console.WriteLine($"Score {score} = Grade {grade}");
        
        // Example 3: Traffic light
        string light = "yellow";
        string action = light switch
        {
            "green" => "Go",
            "yellow" => "Slow down",
            "red" => "Stop",
            _ => "Unknown signal"
        };
        Console.WriteLine($"Light: {light} => {action}");
    }
}`}
/>

## Pattern Matching with Types

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

abstract class Shape { }
class Circle : Shape { public double Radius { get; set; } }
class Rectangle : Shape { public double Width { get; set; } public double Height { get; set; } }
class Triangle : Shape { public double Base { get; set; } public double Height { get; set; } }

class Program
{
    static void Main()
    {
        List<Shape> shapes = new List<Shape>
        {
            new Circle { Radius = 5 },
            new Rectangle { Width = 10, Height = 5 },
            new Triangle { Base = 8, Height = 6 },
            new Circle { Radius = 3 }
        };
        
        Console.WriteLine("Shape Areas:");
        foreach (var shape in shapes)
        {
            double area = CalculateArea(shape);
            Console.WriteLine($"  {shape.GetType().Name}: {area:F2}");
        }
    }
    
    static double CalculateArea(Shape shape) => shape switch
    {
        Circle c => Math.PI * c.Radius * c.Radius,
        Rectangle r => r.Width * r.Height,
        Triangle t => 0.5 * t.Base * t.Height,
        null => throw new ArgumentNullException(nameof(shape)),
        _ => throw new ArgumentException("Unknown shape")
    };
}`}
/>

## Property Patterns

Match based on object properties:

<CodeEditor 
  initialCode={`using System;

class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Country { get; set; }
}

class Program
{
    static void Main()
    {
        var people = new[]
        {
            new Person { Name = "Alice", Age = 25, Country = "USA" },
            new Person { Name = "Bob", Age = 17, Country = "UK" },
            new Person { Name = "Charlie", Age = 30, Country = "USA" },
            new Person { Name = "Diana", Age = 15, Country = "Canada" }
        };
        
        Console.WriteLine("Eligibility Check:");
        foreach (var person in people)
        {
            string status = GetStatus(person);
            Console.WriteLine($"  {person.Name}: {status}");
        }
    }
    
    static string GetStatus(Person person) => person switch
    {
        // Property patterns
        { Age: < 18 } => "Minor - Not eligible",
        { Country: "USA", Age: >= 21 } => "US Adult - Full access",
        { Country: "USA", Age: >= 18 } => "US Young Adult - Limited access",
        { Country: "UK" or "Canada", Age: >= 18 } => "International Adult - Full access",
        _ => "Other - Standard access"
    };
}`}
/>

## Tuple Patterns

Match multiple values at once:

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Rock-Paper-Scissors game
        Console.WriteLine("Rock-Paper-Scissors Results:");
        
        var games = new[]
        {
            ("rock", "scissors"),
            ("paper", "rock"),
            ("scissors", "paper"),
            ("rock", "rock"),
            ("paper", "scissors")
        };
        
        foreach (var (player1, player2) in games)
        {
            string result = DetermineWinner(player1, player2);
            Console.WriteLine($"  {player1} vs {player2}: {result}");
        }
        
        // State machine example
        Console.WriteLine("\\nVending Machine:");
        string state = "idle";
        string[] actions = { "insert_coin", "select_item", "dispense", "reset" };
        
        foreach (var action in actions)
        {
            state = ProcessVendingMachine(state, action);
            Console.WriteLine($"  After '{action}': {state}");
        }
    }
    
    static string DetermineWinner(string p1, string p2) => (p1, p2) switch
    {
        ("rock", "scissors") => "Player 1 wins",
        ("paper", "rock") => "Player 1 wins",
        ("scissors", "paper") => "Player 1 wins",
        ("scissors", "rock") => "Player 2 wins",
        ("rock", "paper") => "Player 2 wins",
        ("paper", "scissors") => "Player 2 wins",
        var (a, b) when a == b => "Tie",
        _ => "Invalid move"
    };
    
    static string ProcessVendingMachine(string currentState, string action) => (currentState, action) switch
    {
        ("idle", "insert_coin") => "has_money",
        ("has_money", "select_item") => "item_selected",
        ("item_selected", "dispense") => "dispensing",
        ("dispensing", "reset") => "idle",
        (_, "reset") => "idle",  // Can always reset
        _ => currentState  // No change
    };
}`}
/>

## Relational Patterns

Use comparison operators in patterns:

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Temperature classification
        int[] temperatures = { -10, 0, 15, 25, 35, 42 };
        
        Console.WriteLine("Temperature Classifications:");
        foreach (int temp in temperatures)
        {
            string classification = ClassifyTemperature(temp);
            Console.WriteLine($"  {temp}Â°C: {classification}");
        }
        
        // Age groups
        int[] ages = { 5, 12, 17, 25, 50, 70, 85 };
        
        Console.WriteLine("\\nAge Groups:");
        foreach (int age in ages)
        {
            string group = GetAgeGroup(age);
            Console.WriteLine($"  Age {age}: {group}");
        }
        
        // Price tiers
        decimal[] prices = { 5.99m, 15.00m, 49.99m, 99.99m, 250.00m };
        
        Console.WriteLine("\\nPrice Tiers:");
        foreach (decimal price in prices)
        {
            string tier = GetPriceTier(price);
            Console.WriteLine($"  ${'{'}price{'}'}: {tier}");
        }
    }
    
    static string ClassifyTemperature(int temp) => temp switch
    {
        < 0 => "Freezing",
        >= 0 and < 10 => "Cold",
        >= 10 and < 20 => "Cool",
        >= 20 and < 30 => "Warm",
        >= 30 and < 40 => "Hot",
        >= 40 => "Extreme heat"
    };
    
    static string GetAgeGroup(int age) => age switch
    {
        < 0 => "Invalid",
        < 13 => "Child",
        < 20 => "Teenager",
        < 30 => "Young Adult",
        < 60 => "Adult",
        < 80 => "Senior",
        _ => "Elderly"
    };
    
    static string GetPriceTier(decimal price) => price switch
    {
        <= 10m => "Budget",
        > 10m and <= 50m => "Standard",
        > 50m and <= 100m => "Premium",
        > 100m => "Luxury"
    };
}`}
/>

## Logical Patterns (and, or, not)

Combine patterns with logical operators:

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Character classification
        char[] chars = { 'A', 'z', '5', ' ', '@', '\\n' };
        
        Console.WriteLine("Character Types:");
        foreach (char c in chars)
        {
            string type = ClassifyChar(c);
            string display = c == '\\n' ? "\\\\n" : c.ToString();
            Console.WriteLine($"  '{display}': {type}");
        }
        
        // Access control
        var requests = new[]
        {
            (role: "admin", action: "delete"),
            (role: "editor", action: "edit"),
            (role: "viewer", action: "view"),
            (role: "viewer", action: "delete"),
            (role: "guest", action: "view")
        };
        
        Console.WriteLine("\\nAccess Control:");
        foreach (var (role, action) in requests)
        {
            bool allowed = IsAllowed(role, action);
            Console.WriteLine($"  {role} -> {action}: {(allowed ? "Allowed" : "Denied")}");
        }
    }
    
    static string ClassifyChar(char c) => c switch
    {
        >= 'A' and <= 'Z' => "Uppercase letter",
        >= 'a' and <= 'z' => "Lowercase letter",
        >= '0' and <= '9' => "Digit",
        ' ' or '\\t' or '\\n' => "Whitespace",
        not (' ' or '\\t' or '\\n') and (>= ' ' and <= '~') => "Special character",
        _ => "Control character"
    };
    
    static bool IsAllowed(string role, string action) => (role, action) switch
    {
        ("admin", _) => true,  // Admin can do anything
        ("editor", "edit" or "view") => true,
        ("viewer", "view") => true,
        (not "guest", not "delete") => true,  // Non-guests can do non-destructive actions
        _ => false
    };
}`}
/>

## List Patterns (C# 11+)

Match against list contents:

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Array patterns
        int[][] arrays = {
            new int[] { },
            new int[] { 1 },
            new int[] { 1, 2 },
            new int[] { 1, 2, 3 },
            new int[] { 1, 2, 3, 4, 5 }
        };
        
        Console.WriteLine("Array Patterns:");
        foreach (var arr in arrays)
        {
            string description = DescribeArray(arr);
            Console.WriteLine($"  [{string.Join(", ", arr)}]: {description}");
        }
        
        // Command parsing
        string[] commands = {
            "help",
            "list all",
            "add item1 item2 item3",
            "remove firstItem"
        };
        
        Console.WriteLine("\\nCommand Parsing:");
        foreach (var cmd in commands)
        {
            string result = ParseCommand(cmd.Split(' '));
            Console.WriteLine($"  '{cmd}' => {result}");
        }
    }
    
    static string DescribeArray(int[] arr) => arr switch
    {
        [] => "Empty array",
        [var single] => $"Single element: {single}",
        [var first, var second] => $"Pair: {first} and {second}",
        [var first, .., var last] => $"Many elements, first={first}, last={last}",
    };
    
    static string ParseCommand(string[] parts) => parts switch
    {
        ["help"] => "Showing help...",
        ["list", var what] => $"Listing {what}",
        ["add", .. var items] => $"Adding {items.Length} items",
        ["remove", var item] => $"Removing '{item}'",
        [var cmd, ..] => $"Unknown command: {cmd}",
        [] => "No command provided"
    };
}`}
/>

## Real-World Example: Order Processing

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

enum OrderStatus { New, Processing, Shipped, Delivered, Cancelled }

class Order
{
    public int Id { get; set; }
    public OrderStatus Status { get; set; }
    public decimal Total { get; set; }
    public bool IsPriority { get; set; }
    public string CustomerType { get; set; }
}

class Program
{
    static void Main()
    {
        var orders = new List<Order>
        {
            new Order { Id = 1, Status = OrderStatus.New, Total = 50, IsPriority = false, CustomerType = "regular" },
            new Order { Id = 2, Status = OrderStatus.New, Total = 150, IsPriority = true, CustomerType = "vip" },
            new Order { Id = 3, Status = OrderStatus.Processing, Total = 75, IsPriority = false, CustomerType = "regular" },
            new Order { Id = 4, Status = OrderStatus.Shipped, Total = 200, IsPriority = true, CustomerType = "vip" },
            new Order { Id = 5, Status = OrderStatus.Cancelled, Total = 30, IsPriority = false, CustomerType = "regular" }
        };
        
        Console.WriteLine("Order Processing:");
        foreach (var order in orders)
        {
            string action = ProcessOrder(order);
            decimal discount = CalculateDiscount(order);
            
            Console.WriteLine($"  Order #{order.Id}:");
            Console.WriteLine($"    Status: {order.Status}");
            Console.WriteLine($"    Action: {action}");
            Console.WriteLine($"    Discount: {discount:P0}");
            Console.WriteLine();
        }
    }
    
    static string ProcessOrder(Order order) => order switch
    {
        // Priority VIP orders get immediate attention
        { IsPriority: true, CustomerType: "vip", Status: OrderStatus.New } 
            => "Rush to fulfillment center",
        
        // Large orders get special handling
        { Total: > 100, Status: OrderStatus.New } 
            => "Flag for quality check before processing",
        
        // Normal new orders
        { Status: OrderStatus.New } 
            => "Add to standard processing queue",
        
        // Cancelled orders
        { Status: OrderStatus.Cancelled } 
            => "Process refund",
        
        // Shipped priority orders
        { IsPriority: true, Status: OrderStatus.Shipped } 
            => "Send tracking notification",
        
        // Default
        _ => "Continue standard workflow"
    };
    
    static decimal CalculateDiscount(Order order) => order switch
    {
        { CustomerType: "vip", Total: > 100 } => 0.20m,
        { CustomerType: "vip" } => 0.10m,
        { Total: > 200 } => 0.15m,
        { Total: > 100 } => 0.05m,
        _ => 0m
    };
}`}
/>

## Key Takeaways

- **Switch expressions** provide concise, expression-based pattern matching
- **Type patterns** allow safe casting with `is` keyword
- **Property patterns** match based on object properties
- **Tuple patterns** match multiple values simultaneously
- **Relational patterns** use `<`, `>`, `<=`, `>=` for comparisons
- **Logical patterns** combine with `and`, `or`, `not`
- **List patterns** (C# 11+) match array/list contents

## Best Practices

1. **Use switch expressions** for cleaner code
2. **Prefer patterns** over complex if-else chains
3. **Use discard (_)** for default cases
4. **Combine patterns** for complex conditions
5. **Keep patterns readable** - don't over-complicate

## Next Steps

Next: **Records** - immutable data types with built-in functionality!
