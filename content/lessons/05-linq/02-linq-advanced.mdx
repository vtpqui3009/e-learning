---
title: "Advanced LINQ"
description: "Master GroupBy, Join, Aggregate, and complex LINQ queries"
order: 2
difficulty: "advanced"
tags: ["linq", "groupby", "join", "aggregate", "advanced"]
duration: "40 minutes"
---

# Advanced LINQ

Master complex LINQ operations including grouping, joining, and custom aggregations for powerful data manipulation.

## GroupBy - Grouping Data

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string City { get; set; }
}

class Program
{
    static void Main()
    {
        List<Person> people = new List<Person>
        {
            new Person { Name = "Alice", Age = 25, City = "New York" },
            new Person { Name = "Bob", Age = 30, City = "Boston" },
            new Person { Name = "Charlie", Age = 25, City = "New York" },
            new Person { Name = "David", Age = 35, City = "Boston" },
            new Person { Name = "Eve", Age = 30, City = "Chicago" }
        };
        
        // Group by city
        var byCity = people.GroupBy(p => p.City);
        
        Console.WriteLine("People by city:");
        foreach (var group in byCity)
        {
            Console.WriteLine($"\\n{group.Key}:");
            foreach (var person in group)
            {
                Console.WriteLine($"  - {person.Name}, {person.Age}");
            }
        }
        
        // Group by age
        var byAge = people.GroupBy(p => p.Age);
        
        Console.WriteLine("\\nPeople by age:");
        foreach (var group in byAge)
        {
            var names = string.Join(", ", group.Select(p => p.Name));
            Console.WriteLine($"Age {group.Key}: {names} (Count: {group.Count()})");
        }
        
        // Group and aggregate
        var cityCounts = people
            .GroupBy(p => p.City)
            .Select(g => new
            {
                City = g.Key,
                Count = g.Count(),
                AvgAge = g.Average(p => p.Age)
            });
        
        Console.WriteLine("\\nCity statistics:");
        foreach (var stat in cityCounts)
        {
            Console.WriteLine($"{stat.City}: {stat.Count} people, avg age \${stat.AvgAge:F1}");
        }
    }
}`}
  title="GroupBy Example"
/>

## Join - Combining Collections

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Course
{
    public int StudentId { get; set; }
    public string CourseName { get; set; }
    public string Grade { get; set; }
}

class Program
{
    static void Main()
    {
        List<Student> students = new List<Student>
        {
            new Student { Id = 1, Name = "Alice" },
            new Student { Id = 2, Name = "Bob" },
            new Student { Id = 3, Name = "Charlie" }
        };
        
        List<Course> courses = new List<Course>
        {
            new Course { StudentId = 1, CourseName = "Math", Grade = "A" },
            new Course { StudentId = 1, CourseName = "Physics", Grade = "B" },
            new Course { StudentId = 2, CourseName = "Math", Grade = "B" },
            new Course { StudentId = 3, CourseName = "Chemistry", Grade = "A" }
        };
        
        // Inner join
        var joined = students.Join(
            courses,
            student => student.Id,
            course => course.StudentId,
            (student, course) => new
            {
                StudentName = student.Name,
                Course = course.CourseName,
                Grade = course.Grade
            }
        );
        
        Console.WriteLine("Student courses:");
        foreach (var item in joined)
        {
            Console.WriteLine($"{item.StudentName}: {item.Course} - {item.Grade}");
        }
        
        // Group join (each student with their courses)
        var groupJoin = students.GroupJoin(
            courses,
            student => student.Id,
            course => course.StudentId,
            (student, studentCourses) => new
            {
                Student = student.Name,
                Courses = studentCourses
            }
        );
        
        Console.WriteLine("\\nStudents with their courses:");
        foreach (var item in groupJoin)
        {
            Console.WriteLine($"\\n{item.Student}:");
            foreach (var course in item.Courses)
            {
                Console.WriteLine($"  - {course.CourseName}: {course.Grade}");
            }
        }
    }
}`}
  title="Join Operations"
/>

## Aggregate - Custom Aggregations

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
        
        // Sum using Aggregate
        int sum = numbers.Aggregate((total, n) => total + n);
        Console.WriteLine($"Sum: {sum}");
        
        // Product
        int product = numbers.Aggregate((result, n) => result * n);
        Console.WriteLine($"Product: {product}");
        
        // With seed value
        int sumPlus100 = numbers.Aggregate(100, (total, n) => total + n);
        Console.WriteLine($"Sum + 100: {sumPlus100}");
        
        // Build string
        List<string> words = new List<string> { "Hello", "World", "from", "LINQ" };
        string sentence = words.Aggregate((result, word) => result + " " + word);
        Console.WriteLine($"\\nSentence: {sentence}");
        
        // Complex aggregation
        var stats = numbers.Aggregate(
            new { Count = 0, Sum = 0, Min = int.MaxValue, Max = int.MinValue },
            (acc, n) => new
            {
                Count = acc.Count + 1,
                Sum = acc.Sum + n,
                Min = Math.Min(acc.Min, n),
                Max = Math.Max(acc.Max, n)
            },
            acc => new
            {
                acc.Count,
                acc.Sum,
                Average = (double)acc.Sum / acc.Count,
                acc.Min,
                acc.Max
            }
        );
        
        Console.WriteLine($"\\nStatistics:");
        Console.WriteLine($"Count: {stats.Count}");
        Console.WriteLine($"Sum: {stats.Sum}");
        Console.WriteLine($"Average: {stats.Average}");
        Console.WriteLine($"Min: {stats.Min}");
        Console.WriteLine($"Max: {stats.Max}");
    }
}`}
  title="Aggregate Function"
/>

## SelectMany - Flattening Collections

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Department
{
    public string Name { get; set; }
    public List<string> Employees { get; set; }
}

class Program
{
    static void Main()
    {
        List<Department> departments = new List<Department>
        {
            new Department 
            { 
                Name = "Engineering",
                Employees = new List<string> { "Alice", "Bob", "Charlie" }
            },
            new Department 
            { 
                Name = "Marketing",
                Employees = new List<string> { "David", "Eve" }
            },
            new Department 
            { 
                Name = "Sales",
                Employees = new List<string> { "Frank" }
            }
        };
        
        // SelectMany flattens nested collections
        var allEmployees = departments.SelectMany(d => d.Employees);
        Console.WriteLine("All employees:");
        Console.WriteLine(string.Join(", ", allEmployees));
        
        // With transformation
        var employeeInfo = departments.SelectMany(
            d => d.Employees,
            (dept, emp) => $"{emp} ({dept.Name})"
        );
        
        Console.WriteLine("\\nEmployee departments:");
        foreach (var info in employeeInfo)
        {
            Console.WriteLine($"  - {info}");
        }
        
        // Multiple levels
        List<List<int>> nestedNumbers = new List<List<int>>
        {
            new List<int> { 1, 2, 3 },
            new List<int> { 4, 5 },
            new List<int> { 6, 7, 8, 9 }
        };
        
        var flatNumbers = nestedNumbers.SelectMany(list => list);
        Console.WriteLine($"\\nFlattened: {string.Join(", ", flatNumbers)}");
    }
}`}
  title="SelectMany - Flattening"
/>

## Distinct, Union, Intersect, Except

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        List<int> list1 = new List<int> { 1, 2, 3, 4, 5 };
        List<int> list2 = new List<int> { 4, 5, 6, 7, 8 };
        List<int> duplicates = new List<int> { 1, 2, 2, 3, 3, 3, 4 };
        
        // Distinct - remove duplicates
        var unique = duplicates.Distinct();
        Console.WriteLine("Distinct: " + string.Join(", ", unique));
        
        // Union - combine and remove duplicates
        var union = list1.Union(list2);
        Console.WriteLine($"\\nUnion of [{string.Join(", ", list1)}]");
        Console.WriteLine($"   and [{string.Join(", ", list2)}]:");
        Console.WriteLine("   = " + string.Join(", ", union));
        
        // Intersect - common elements
        var intersect = list1.Intersect(list2);
        Console.WriteLine($"\\nIntersect: {string.Join(", ", intersect)}");
        
        // Except - elements in first but not second
        var except1 = list1.Except(list2);
        var except2 = list2.Except(list1);
        Console.WriteLine($"\\nList1 Except List2: {string.Join(", ", except1)}");
        Console.WriteLine($"List2 Except List1: {string.Join(", ", except2)}");
        
        // With strings
        List<string> tech1 = new List<string> { "C#", "Java", "Python" };
        List<string> tech2 = new List<string> { "Python", "JavaScript", "C#" };
        
        var commonTech = tech1.Intersect(tech2);
        Console.WriteLine($"\\nCommon technologies: {string.Join(", ", commonTech)}");
    }
}`}
  title="Set Operations"
/>

## Skip, Take, Pagination

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        List<int> numbers = Enumerable.Range(1, 100).ToList();
        
        // Take first 5
        var firstFive = numbers.Take(5);
        Console.WriteLine("First 5: " + string.Join(", ", firstFive));
        
        // Skip first 5
        var skipFive = numbers.Skip(5).Take(5);
        Console.WriteLine("Skip 5, take 5: " + string.Join(", ", skipFive));
        
        // TakeWhile - take until condition fails
        var takeWhile = numbers.TakeWhile(n => n < 10);
        Console.WriteLine($"\\nTake while < 10: {string.Join(", ", takeWhile)}");
        
        // SkipWhile - skip until condition fails
        var skipWhile = numbers.SkipWhile(n => n < 95).Take(10);
        Console.WriteLine($"Skip while < 95, take 10: {string.Join(", ", skipWhile)}");
        
        // Pagination example
        int pageSize = 10;
        int pageNumber = 3;
        
        var page = numbers
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize);
        
        Console.WriteLine($"\\nPage {pageNumber} (size {pageSize}):");
        Console.WriteLine(string.Join(", ", page));
        
        // Get page count
        int totalPages = (int)Math.Ceiling((double)numbers.Count / pageSize);
        Console.WriteLine($"Total pages: {totalPages}");
    }
}`}
  title="Skip and Take"
/>

## Complex Real-World Example

<CodeEditor 
  language="csharp"
  code={`using System;
using System.Linq;
using System.Collections.Generic;

class Order
{
    public int OrderId { get; set; }
    public int CustomerId { get; set; }
    public DateTime Date { get; set; }
    public decimal Total { get; set; }
}

class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string City { get; set; }
}

class Program
{
    static void Main()
    {
        List<Customer> customers = new List<Customer>
        {
            new Customer { Id = 1, Name = "Alice", City = "New York" },
            new Customer { Id = 2, Name = "Bob", City = "Boston" },
            new Customer { Id = 3, Name = "Charlie", City = "New York" }
        };
        
        List<Order> orders = new List<Order>
        {
            new Order { OrderId = 1, CustomerId = 1, Total = 150, Date = DateTime.Now.AddDays(-10) },
            new Order { OrderId = 2, CustomerId = 1, Total = 200, Date = DateTime.Now.AddDays(-5) },
            new Order { OrderId = 3, CustomerId = 2, Total = 300, Date = DateTime.Now.AddDays(-8) },
            new Order { OrderId = 4, CustomerId = 3, Total = 100, Date = DateTime.Now.AddDays(-2) },
            new Order { OrderId = 5, CustomerId = 1, Total = 250, Date = DateTime.Now.AddDays(-1) }
        };
        
        // Complex query: Customer order summary
        var customerSummary = customers
            .GroupJoin(
                orders,
                c => c.Id,
                o => o.CustomerId,
                (customer, customerOrders) => new
                {
                    Customer = customer.Name,
                    City = customer.City,
                    Orders = customerOrders,
                    TotalSpent = customerOrders.Sum(o => o.Total),
                    OrderCount = customerOrders.Count(),
                    LastOrderDate = customerOrders.Any() ? 
                        customerOrders.Max(o => o.Date) : (DateTime?)null
                }
            )
            .OrderByDescending(cs => cs.TotalSpent);
        
        Console.WriteLine("Customer Summary:");
        foreach (var cs in customerSummary)
        {
            Console.WriteLine($"\\n{cs.Customer} ({cs.City}):");
            Console.WriteLine($"  Orders: {cs.OrderCount}");
            Console.WriteLine($"  Total Spent: \${cs.TotalSpent}");
            if (cs.LastOrderDate.HasValue)
                Console.WriteLine($"  Last Order: {cs.LastOrderDate.Value:yyyy-MM-dd}");
        }
        
        // City statistics
        var cityStats = customers
            .Join(
                orders,
                c => c.Id,
                o => o.CustomerId,
                (c, o) => new { c.City, o.Total }
            )
            .GroupBy(x => x.City)
            .Select(g => new
            {
                City = g.Key,
                TotalRevenue = g.Sum(x => x.Total),
                OrderCount = g.Count(),
                AvgOrderValue = g.Average(x => x.Total)
            });
        
        Console.WriteLine("\\n\\nCity Statistics:");
        foreach (var stat in cityStats)
        {
            Console.WriteLine($"{stat.City}:");
            Console.WriteLine($"  Total Revenue: \${stat.TotalRevenue}");
            Console.WriteLine($"  Orders: {stat.OrderCount}");
            Console.WriteLine($"  Avg Order: \${stat.AvgOrderValue:F2}");
        }
    }
}`}
  title="Complex Real-World Query"
/>

## Best Practices

1. **Use method syntax** - More composable than query syntax
2. **Materialize with ToList()** - When you need results multiple times
3. **Avoid multiple enumerations** - Cache results if needed
4. **Use AsEnumerable()** - Switch from IQueryable to LINQ to Objects
5. **Consider performance** - Some operations are expensive
6. **Break complex queries** - Into intermediate variables for readability

## Key Takeaways

- **GroupBy** organizes data into groups by key
- **Join** combines collections based on matching keys
- **Aggregate** enables custom accumulation logic
- **SelectMany** flattens nested collections
- **Set operations**: Distinct, Union, Intersect, Except
- **Pagination**: Skip and Take for efficient data retrieval
- LINQ enables **declarative, composable** data queries

## Next Steps

Next section: **Modern C# Features** including Async/Await, Pattern Matching, and Records!
