---
title: "Properties"
description: "Learn how to use C# properties for cleaner encapsulation"
order: 3
difficulty: "intermediate"
tags: ["oop", "properties", "getters", "setters"]
duration: "25 minutes"
---

# Properties in C#

Properties provide a flexible mechanism for reading, writing, or computing the values of private fields. They combine the simplicity of fields with the power of methods.

## What are Properties?

Properties look like fields but work like methods. They provide a way to access private data with automatic encapsulation.

## Basic Property Syntax

<CodeEditor 
  initialCode={`using System;

class Person
{
    // Private backing field
    private string name;
    
    // Property with getter and setter
    public string Name
    {
        get { return name; }      // Returns the value
        set { name = value; }     // Sets the value
    }
    
    // Property with validation
    private int age;
    public int Age
    {
        get { return age; }
        set 
        { 
            if (value >= 0 && value <= 150)
            {
                age = value;
            }
            else
            {
                Console.WriteLine("Invalid age value");
            }
        }
    }
}

class Program
{
    static void Main()
    {
        Person person = new Person();
        
        // Set values using properties
        person.Name = "John";
        person.Age = 30;
        
        // Get values using properties
        Console.WriteLine($"Name: {person.Name}");
        Console.WriteLine($"Age: {person.Age}");
        
        // Try invalid age
        person.Age = -5;  // Will print error
        Console.WriteLine($"Age is still: {person.Age}");
    }
}`}
/>

## Auto-Implemented Properties

For simple properties without validation logic, use auto-implemented properties:

<CodeEditor 
  initialCode={`using System;

class Product
{
    // Auto-implemented properties
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
    
    // Read-only auto property (set only in constructor)
    public string Id { get; }
    
    // Auto property with private setter
    public DateTime CreatedAt { get; private set; }
    
    public Product(string name, decimal price)
    {
        Id = Guid.NewGuid().ToString().Substring(0, 8);
        Name = name;
        Price = price;
        Stock = 0;
        CreatedAt = DateTime.Now;
    }
    
    public void AddStock(int quantity)
    {
        Stock += quantity;
        Console.WriteLine($"Added {quantity} units. Total stock: {Stock}");
    }
}

class Program
{
    static void Main()
    {
        Product product = new Product("Laptop", 999.99m);
        
        Console.WriteLine($"Product ID: {product.Id}");
        Console.WriteLine($"Name: {product.Name}");
        Console.WriteLine($"Price: ${'{'}product.Price{'}'}");
        Console.WriteLine($"Created: {product.CreatedAt}");
        
        product.AddStock(10);
        
        // Can change Name and Price
        product.Name = "Gaming Laptop";
        product.Price = 1299.99m;
        
        // Cannot change Id - read-only
        // product.Id = "newid"; // Compile error!
        
        // Cannot change CreatedAt from outside - private setter
        // product.CreatedAt = DateTime.Now; // Compile error!
        
        Console.WriteLine($"\nUpdated: {product.Name} - ${'{'}product.Price{'}'}");
    }
}`}
/>

## Expression-Bodied Properties

Use arrow syntax for concise read-only properties:

<CodeEditor 
  initialCode={`using System;

class Rectangle
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    // Expression-bodied read-only properties
    public double Area => Width * Height;
    public double Perimeter => 2 * (Width + Height);
    public bool IsSquare => Width == Height;
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }
}

class Circle
{
    public double Radius { get; set; }
    
    public double Area => Math.PI * Radius * Radius;
    public double Circumference => 2 * Math.PI * Radius;
    public double Diameter => 2 * Radius;
    
    public Circle(double radius)
    {
        Radius = radius;
    }
}

class Program
{
    static void Main()
    {
        Rectangle rect = new Rectangle(10, 5);
        Console.WriteLine($"Rectangle: {rect.Width} x {rect.Height}");
        Console.WriteLine($"  Area: {rect.Area}");
        Console.WriteLine($"  Perimeter: {rect.Perimeter}");
        Console.WriteLine($"  Is Square: {rect.IsSquare}");
        
        Circle circle = new Circle(5);
        Console.WriteLine($"\\nCircle: radius = {circle.Radius}");
        Console.WriteLine($"  Diameter: {circle.Diameter}");
        Console.WriteLine($"  Area: {circle.Area:F2}");
        Console.WriteLine($"  Circumference: {circle.Circumference:F2}");
    }
}`}
/>

## Properties with Validation

<CodeEditor 
  initialCode={`using System;

class Employee
{
    private string email;
    private decimal salary;
    
    public string Name { get; set; }
    
    public string Email
    {
        get { return email; }
        set
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Email cannot be empty");
            }
            if (!value.Contains("@"))
            {
                throw new ArgumentException("Invalid email format");
            }
            email = value;
        }
    }
    
    public decimal Salary
    {
        get { return salary; }
        set
        {
            if (value < 0)
            {
                throw new ArgumentException("Salary cannot be negative");
            }
            salary = value;
        }
    }
    
    // Computed property
    public decimal MonthlySalary => Salary / 12;
}

class Program
{
    static void Main()
    {
        Employee emp = new Employee();
        
        emp.Name = "John Doe";
        emp.Salary = 60000;
        emp.Email = "john@example.com";
        
        Console.WriteLine($"Employee: {emp.Name}");
        Console.WriteLine($"Email: {emp.Email}");
        Console.WriteLine($"Annual Salary: ${'{'}emp.Salary{'}'}");
        Console.WriteLine($"Monthly Salary: ${'{'}emp.MonthlySalary:F2{'}'}");
        
        // Try invalid values
        try
        {
            emp.Email = "invalid-email";
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"\\nError: {ex.Message}");
        }
        
        try
        {
            emp.Salary = -1000;
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}`}
/>

## Init-Only Properties (C# 9+)

Properties that can only be set during object initialization:

<CodeEditor 
  initialCode={`using System;

class ImmutablePerson
{
    // Init-only properties - can only be set during initialization
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public DateTime BirthDate { get; init; }
    
    // Computed read-only properties
    public string FullName => $"{FirstName} {LastName}";
    public int Age => (int)((DateTime.Now - BirthDate).TotalDays / 365.25);
}

class Program
{
    static void Main()
    {
        // Using object initializer
        var person = new ImmutablePerson
        {
            FirstName = "John",
            LastName = "Doe",
            BirthDate = new DateTime(1990, 5, 15)
        };
        
        Console.WriteLine($"Full Name: {person.FullName}");
        Console.WriteLine($"Birth Date: {person.BirthDate:d}");
        Console.WriteLine($"Age: {person.Age}");
        
        // Cannot modify after initialization:
        // person.FirstName = "Jane"; // Compile error!
        
        Console.WriteLine("\\nInit-only properties prevent modification after creation.");
    }
}`}
/>

## Property Access Modifiers

<CodeEditor 
  initialCode={`using System;

class Account
{
    // Public get, private set
    public string AccountNumber { get; private set; }
    
    // Public get, protected set
    public decimal Balance { get; protected set; }
    
    // Public get and set
    public string OwnerName { get; set; }
    
    // Internal property
    internal string InternalCode { get; set; }
    
    public Account(string number, string owner)
    {
        AccountNumber = number;
        OwnerName = owner;
        Balance = 0;
        InternalCode = "ACC-" + number;
    }
    
    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            Balance += amount;
            Console.WriteLine($"Deposited ${'{'}amount{'}'}. Balance: ${'{'}Balance{'}'}");
        }
    }
}

class SavingsAccount : Account
{
    public decimal InterestRate { get; set; }
    
    public SavingsAccount(string number, string owner, decimal rate) 
        : base(number, owner)
    {
        InterestRate = rate;
    }
    
    public void AddInterest()
    {
        // Can access Balance because it's protected
        decimal interest = Balance * InterestRate / 100;
        Balance += interest;  // Can modify via protected setter
        Console.WriteLine($"Added ${'{'}interest:F2{'}'} interest. Balance: ${'{'}Balance:F2{'}'}");
    }
}

class Program
{
    static void Main()
    {
        var account = new Account("12345", "John Doe");
        
        Console.WriteLine($"Account: {account.AccountNumber}");
        Console.WriteLine($"Owner: {account.OwnerName}");
        
        account.Deposit(1000);
        
        // Can change owner name
        account.OwnerName = "Jane Doe";
        
        // Cannot change account number or balance directly
        // account.AccountNumber = "99999"; // Compile error!
        // account.Balance = 1000000; // Compile error!
        
        Console.WriteLine("\\n--- Savings Account ---");
        var savings = new SavingsAccount("67890", "Bob Smith", 2.5m);
        savings.Deposit(1000);
        savings.AddInterest();
    }
}`}
/>

## Indexers

Special properties that allow array-like access to objects:

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Library
{
    private Dictionary<string, string> books = new Dictionary<string, string>();
    
    // Indexer by ISBN
    public string this[string isbn]
    {
        get
        {
            if (books.ContainsKey(isbn))
                return books[isbn];
            return "Book not found";
        }
        set
        {
            books[isbn] = value;
            Console.WriteLine($"Added/Updated: {value} (ISBN: {isbn})");
        }
    }
    
    public int Count => books.Count;
    
    public void ListAll()
    {
        Console.WriteLine($"\\nLibrary has {Count} books:");
        foreach (var book in books)
        {
            Console.WriteLine($"  {book.Key}: {book.Value}");
        }
    }
}

class Matrix
{
    private int[,] data;
    
    public int Rows { get; }
    public int Columns { get; }
    
    public Matrix(int rows, int cols)
    {
        Rows = rows;
        Columns = cols;
        data = new int[rows, cols];
    }
    
    // Two-dimensional indexer
    public int this[int row, int col]
    {
        get { return data[row, col]; }
        set { data[row, col] = value; }
    }
}

class Program
{
    static void Main()
    {
        Library library = new Library();
        
        // Use indexer to add books
        library["978-0-13-468599-1"] = "The C# Programming Language";
        library["978-1-491-95025-9"] = "C# in Depth";
        library["978-0-596-00712-6"] = "Head First C#";
        
        // Use indexer to access books
        Console.WriteLine($"\\nLookup: {library["978-0-13-468599-1"]}");
        Console.WriteLine($"Unknown: {library["000-0-000-00000-0"]}");
        
        library.ListAll();
        
        // Matrix with 2D indexer
        Console.WriteLine("\\n--- Matrix ---");
        Matrix m = new Matrix(2, 3);
        m[0, 0] = 1; m[0, 1] = 2; m[0, 2] = 3;
        m[1, 0] = 4; m[1, 1] = 5; m[1, 2] = 6;
        
        Console.WriteLine($"Matrix[1,2] = {m[1, 2]}");
    }
}`}
/>

## Complete Example: Student Management

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Student
{
    private static int nextId = 1;
    private List<int> grades = new List<int>();
    
    // Auto properties
    public int Id { get; }
    public string Name { get; set; }
    
    // Property with validation
    private int age;
    public int Age
    {
        get => age;
        set => age = (value >= 5 && value <= 100) ? value : age;
    }
    
    // Computed properties
    public double Average => grades.Count > 0 
        ? grades.Average() 
        : 0;
    
    public string Grade => Average switch
    {
        >= 90 => "A",
        >= 80 => "B",
        >= 70 => "C",
        >= 60 => "D",
        _ => "F"
    };
    
    public int GradeCount => grades.Count;
    
    public Student(string name, int age)
    {
        Id = nextId++;
        Name = name;
        Age = age;
    }
    
    public void AddGrade(int grade)
    {
        if (grade >= 0 && grade <= 100)
        {
            grades.Add(grade);
        }
    }
}

class Program
{
    static void Main()
    {
        var students = new List<Student>
        {
            new Student("Alice", 20),
            new Student("Bob", 22),
            new Student("Charlie", 19)
        };
        
        // Add grades
        students[0].AddGrade(95);
        students[0].AddGrade(88);
        students[0].AddGrade(92);
        
        students[1].AddGrade(78);
        students[1].AddGrade(82);
        students[1].AddGrade(75);
        
        students[2].AddGrade(65);
        students[2].AddGrade(70);
        students[2].AddGrade(68);
        
        Console.WriteLine("Student Report:");
        Console.WriteLine("================");
        foreach (var s in students)
        {
            Console.WriteLine($"ID: {s.Id}");
            Console.WriteLine($"Name: {s.Name}");
            Console.WriteLine($"Age: {s.Age}");
            Console.WriteLine($"Grades: {s.GradeCount}");
            Console.WriteLine($"Average: {s.Average:F1}");
            Console.WriteLine($"Letter Grade: {s.Grade}");
            Console.WriteLine();
        }
    }
}`}
/>

## Key Takeaways

- **Properties** provide controlled access to private fields
- **Auto-implemented properties** reduce boilerplate code
- **Expression-bodied properties** enable concise computed values
- **Access modifiers** on getters/setters control read/write access
- **Init-only properties** allow setting only during initialization
- **Indexers** provide array-like access to objects

## Best Practices

1. Use **auto-properties** for simple get/set scenarios
2. Add **validation** in setters for data integrity
3. Use **expression-bodied** syntax for computed properties
4. Make setters **private** when external modification isn't needed
5. Consider **init-only** properties for immutable data

## Next Steps

Next lesson: **Constructors** - Learn how to properly initialize objects!
