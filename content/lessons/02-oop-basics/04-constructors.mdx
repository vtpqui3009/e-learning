---
title: "Constructors"
description: "Learn how to initialize objects properly using constructors"
order: 4
difficulty: "intermediate"
tags: ["oop", "constructors", "initialization"]
duration: "25 minutes"
---

# Constructors in C#

Constructors are special methods that initialize new instances of a class. They ensure objects start in a valid state with all necessary data.

## What is a Constructor?

A constructor is a method that:
- Has the **same name** as the class
- Has **no return type** (not even void)
- Is called automatically when creating an object with `new`

## Default Constructor

<CodeEditor 
  initialCode={`using System;

class Person
{
    public string Name;
    public int Age;
    
    // Default constructor (no parameters)
    public Person()
    {
        Name = "Unknown";
        Age = 0;
        Console.WriteLine("Default constructor called");
    }
}

class Program
{
    static void Main()
    {
        // Calls the default constructor
        Person person = new Person();
        
        Console.WriteLine($"Name: {person.Name}");
        Console.WriteLine($"Age: {person.Age}");
    }
}`}
/>

## Parameterized Constructors

Accept parameters to initialize the object with specific values:

<CodeEditor 
  initialCode={`using System;

class Person
{
    public string Name;
    public int Age;
    public string Email;
    
    // Parameterized constructor
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
        Email = "";
        Console.WriteLine($"Created person: {name}, age {age}");
    }
    
    // Constructor with all parameters
    public Person(string name, int age, string email)
    {
        Name = name;
        Age = age;
        Email = email;
        Console.WriteLine($"Created person with email: {name}");
    }
}

class Program
{
    static void Main()
    {
        Person person1 = new Person("John", 30);
        Console.WriteLine($"  Email: '{person1.Email}'");
        
        Console.WriteLine();
        
        Person person2 = new Person("Jane", 25, "jane@example.com");
        Console.WriteLine($"  Email: '{person2.Email}'");
    }
}`}
/>

## Constructor Overloading

Multiple constructors with different parameters:

<CodeEditor 
  initialCode={`using System;

class Rectangle
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    // Default - unit square
    public Rectangle()
    {
        Width = 1;
        Height = 1;
        Console.WriteLine("Created unit square");
    }
    
    // Square constructor
    public Rectangle(double size)
    {
        Width = size;
        Height = size;
        Console.WriteLine($"Created square: {size}x{size}");
    }
    
    // Full constructor
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
        Console.WriteLine($"Created rectangle: {width}x{height}");
    }
    
    public double Area => Width * Height;
}

class Program
{
    static void Main()
    {
        Rectangle r1 = new Rectangle();
        Console.WriteLine($"  Area: {r1.Area}\\n");
        
        Rectangle r2 = new Rectangle(5);
        Console.WriteLine($"  Area: {r2.Area}\\n");
        
        Rectangle r3 = new Rectangle(10, 5);
        Console.WriteLine($"  Area: {r3.Area}");
    }
}`}
/>

## Constructor Chaining

Call one constructor from another using `this`:

<CodeEditor 
  initialCode={`using System;

class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
    
    // Primary constructor with all parameters
    public Employee(int id, string name, string department, decimal salary)
    {
        Id = id;
        Name = name;
        Department = department;
        Salary = salary;
        Console.WriteLine($"Created: {name} in {department}");
    }
    
    // Chain to primary constructor with default department
    public Employee(int id, string name, decimal salary)
        : this(id, name, "General", salary)
    {
        Console.WriteLine("  (Used default department)");
    }
    
    // Chain with default salary too
    public Employee(int id, string name)
        : this(id, name, "General", 50000)
    {
        Console.WriteLine("  (Used default salary)");
    }
    
    // Copy constructor
    public Employee(Employee other)
        : this(other.Id, other.Name, other.Department, other.Salary)
    {
        Console.WriteLine("  (Copied from another employee)");
    }
}

class Program
{
    static void Main()
    {
        var emp1 = new Employee(1, "Alice", "Engineering", 75000);
        Console.WriteLine();
        
        var emp2 = new Employee(2, "Bob", 60000);
        Console.WriteLine();
        
        var emp3 = new Employee(3, "Charlie");
        Console.WriteLine();
        
        var emp4 = new Employee(emp1);
        emp4.Id = 4;
        emp4.Name = "Alice Clone";
    }
}`}
/>

## Validation in Constructors

<CodeEditor 
  initialCode={`using System;

class BankAccount
{
    public string AccountNumber { get; }
    public string OwnerName { get; }
    public decimal Balance { get; private set; }
    
    public BankAccount(string accountNumber, string ownerName, decimal initialBalance)
    {
        // Validate account number
        if (string.IsNullOrWhiteSpace(accountNumber))
        {
            throw new ArgumentException("Account number is required");
        }
        
        if (accountNumber.Length < 6)
        {
            throw new ArgumentException("Account number must be at least 6 characters");
        }
        
        // Validate owner name
        if (string.IsNullOrWhiteSpace(ownerName))
        {
            throw new ArgumentException("Owner name is required");
        }
        
        // Validate balance
        if (initialBalance < 0)
        {
            throw new ArgumentException("Initial balance cannot be negative");
        }
        
        AccountNumber = accountNumber;
        OwnerName = ownerName;
        Balance = initialBalance;
        
        Console.WriteLine($"Account created: {accountNumber} for {ownerName}");
    }
}

class Program
{
    static void Main()
    {
        // Valid account
        try
        {
            var account1 = new BankAccount("123456", "John Doe", 1000);
            Console.WriteLine($"Balance: ${'{'}account1.Balance{'}'}\n");
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"Error: {ex.Message}\\n");
        }
        
        // Invalid: short account number
        try
        {
            var account2 = new BankAccount("123", "Jane", 500);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"Error: {ex.Message}\\n");
        }
        
        // Invalid: negative balance
        try
        {
            var account3 = new BankAccount("789012", "Bob", -100);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}`}
/>

## Static Constructors

Initialize static members of a class:

<CodeEditor 
  initialCode={`using System;

class Configuration
{
    // Static fields
    public static string AppName { get; private set; }
    public static string Version { get; private set; }
    public static DateTime StartTime { get; private set; }
    
    // Static constructor - called once before first use
    static Configuration()
    {
        Console.WriteLine("Static constructor called");
        AppName = "My Application";
        Version = "1.0.0";
        StartTime = DateTime.Now;
    }
    
    // Instance members
    public string InstanceId { get; }
    
    public Configuration()
    {
        InstanceId = Guid.NewGuid().ToString().Substring(0, 8);
        Console.WriteLine($"Instance constructor called: {InstanceId}");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Before accessing Configuration...");
        
        // Accessing static property triggers static constructor
        Console.WriteLine($"App: {Configuration.AppName}");
        Console.WriteLine($"Version: {Configuration.Version}");
        Console.WriteLine();
        
        // Create instances - static constructor only runs once
        var config1 = new Configuration();
        var config2 = new Configuration();
        
        Console.WriteLine($"\\nStart time: {Configuration.StartTime}");
    }
}`}
/>

## Private Constructors

Prevent direct instantiation (used with factory patterns):

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Logger
{
    private static Logger instance;
    private List<string> logs = new List<string>();
    
    // Private constructor - cannot be called from outside
    private Logger()
    {
        Console.WriteLine("Logger instance created");
    }
    
    // Factory method to get the single instance (Singleton pattern)
    public static Logger GetInstance()
    {
        if (instance == null)
        {
            instance = new Logger();
        }
        return instance;
    }
    
    public void Log(string message)
    {
        string entry = $"[{DateTime.Now:HH:mm:ss}] {message}";
        logs.Add(entry);
        Console.WriteLine(entry);
    }
    
    public void ShowAll()
    {
        Console.WriteLine("\\nAll logs:");
        foreach (var log in logs)
        {
            Console.WriteLine($"  {log}");
        }
    }
}

class Program
{
    static void Main()
    {
        // Cannot do: var logger = new Logger(); // Compile error!
        
        // Must use factory method
        Logger logger1 = Logger.GetInstance();
        logger1.Log("Application started");
        
        Logger logger2 = Logger.GetInstance();
        logger2.Log("User logged in");
        
        // Both references point to same instance
        Console.WriteLine($"\\nSame instance: {logger1 == logger2}");
        
        logger1.ShowAll();
    }
}`}
/>

## Expression-Bodied Constructors

<CodeEditor 
  initialCode={`using System;

class Point
{
    public double X { get; }
    public double Y { get; }
    
    // Expression-bodied constructor
    public Point(double x, double y) => (X, Y) = (x, y);
    
    public double DistanceFromOrigin => Math.Sqrt(X * X + Y * Y);
    
    public override string ToString() => $"({X}, {Y})";
}

class Temperature
{
    public double Celsius { get; }
    
    // Simple expression-bodied constructor
    public Temperature(double celsius) => Celsius = celsius;
    
    public double Fahrenheit => Celsius * 9 / 5 + 32;
    public double Kelvin => Celsius + 273.15;
    
    public override string ToString() => $"{Celsius}°C";
}

class Program
{
    static void Main()
    {
        var point = new Point(3, 4);
        Console.WriteLine($"Point: {point}");
        Console.WriteLine($"Distance from origin: {point.DistanceFromOrigin}");
        
        var temp = new Temperature(25);
        Console.WriteLine($"\\nTemperature: {temp}");
        Console.WriteLine($"Fahrenheit: {temp.Fahrenheit}°F");
        Console.WriteLine($"Kelvin: {temp.Kelvin}K");
    }
}`}
/>

## Primary Constructors (C# 12)

<CodeEditor 
  initialCode={`using System;

// Primary constructor syntax (C# 12+)
// Parameters become available throughout the class
class Person(string name, int age)
{
    public string Name { get; } = name;
    public int Age { get; } = age;
    
    public void Greet()
    {
        // Can access primary constructor parameters
        Console.WriteLine($"Hello, I'm {name} and I'm {age} years old.");
    }
}

// Traditional approach for comparison
class PersonTraditional
{
    public string Name { get; }
    public int Age { get; }
    
    public PersonTraditional(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    public void Greet()
    {
        Console.WriteLine($"Hello, I'm {Name} and I'm {Age} years old.");
    }
}

class Program
{
    static void Main()
    {
        var person = new Person("Alice", 28);
        Console.WriteLine($"Name: {person.Name}");
        Console.WriteLine($"Age: {person.Age}");
        person.Greet();
    }
}`}
/>

## Complete Example: Order System

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class OrderItem
{
    public string ProductName { get; }
    public decimal Price { get; }
    public int Quantity { get; }
    
    public OrderItem(string productName, decimal price, int quantity = 1)
    {
        if (string.IsNullOrWhiteSpace(productName))
            throw new ArgumentException("Product name required");
        if (price < 0)
            throw new ArgumentException("Price cannot be negative");
        if (quantity < 1)
            throw new ArgumentException("Quantity must be at least 1");
            
        ProductName = productName;
        Price = price;
        Quantity = quantity;
    }
    
    public decimal Total => Price * Quantity;
}

class Order
{
    private static int nextOrderId = 1000;
    private List<OrderItem> items = new List<OrderItem>();
    
    public int OrderId { get; }
    public string CustomerName { get; }
    public DateTime OrderDate { get; }
    
    public Order(string customerName)
    {
        if (string.IsNullOrWhiteSpace(customerName))
            throw new ArgumentException("Customer name required");
            
        OrderId = nextOrderId++;
        CustomerName = customerName;
        OrderDate = DateTime.Now;
    }
    
    public void AddItem(string product, decimal price, int qty = 1)
    {
        items.Add(new OrderItem(product, price, qty));
    }
    
    public decimal Total
    {
        get
        {
            decimal sum = 0;
            foreach (var item in items)
                sum += item.Total;
            return sum;
        }
    }
    
    public void PrintReceipt()
    {
        Console.WriteLine($"Order #{OrderId}");
        Console.WriteLine($"Customer: {CustomerName}");
        Console.WriteLine($"Date: {OrderDate:g}");
        Console.WriteLine("-------------------");
        
        foreach (var item in items)
        {
            Console.WriteLine($"{item.ProductName} x{item.Quantity} @ ${'{'}item.Price{'}'} = ${'{'}item.Total{'}'}");
        }

        Console.WriteLine("-------------------");
        Console.WriteLine($"TOTAL: ${'{'}Total{'}'}");
    }
}

class Program
{
    static void Main()
    {
        var order = new Order("John Smith");
        
        order.AddItem("Laptop", 999.99m);
        order.AddItem("Mouse", 29.99m, 2);
        order.AddItem("Keyboard", 79.99m);
        
        order.PrintReceipt();
    }
}`}
/>

## Key Takeaways

- **Constructors** initialize objects when created with `new`
- **Default constructors** have no parameters
- **Parameterized constructors** accept initialization values
- **Constructor chaining** with `this` avoids code duplication
- **Static constructors** initialize static members once
- **Private constructors** enable singleton and factory patterns

## Best Practices

1. **Validate parameters** in constructors
2. **Use constructor chaining** to avoid duplicating code
3. **Initialize to valid state** - objects should be usable after construction
4. **Use readonly/init properties** for immutable data
5. **Consider factory methods** for complex initialization logic

## Next Steps

Next lesson: **Static Members** - Learn about class-level data and methods!
