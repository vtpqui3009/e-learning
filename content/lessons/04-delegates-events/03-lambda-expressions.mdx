---
title: "Lambda Expressions"
description: "Learn how to write concise inline functions with lambda expressions"
order: 3
difficulty: "advanced"
tags: ["lambda", "anonymous functions", "LINQ", "functional"]
duration: "25 minutes"
---

# Lambda Expressions in C#

Lambda expressions provide a concise way to write anonymous methods. They're essential for LINQ, event handlers, and functional programming in C#.

## What is a Lambda Expression?

A lambda expression is an anonymous function that can contain expressions and statements. It uses the `=>` operator (called "goes to" or "arrow").

## Basic Lambda Syntax

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Expression lambda: (parameters) => expression
        Func<int, int> square = x => x * x;
        Func<int, int> cube = x => x * x * x;
        
        Console.WriteLine($"Square of 5: {square(5)}");
        Console.WriteLine($"Cube of 5: {cube(5)}");
        
        // Multiple parameters
        Func<int, int, int> add = (a, b) => a + b;
        Func<int, int, int> multiply = (a, b) => a * b;
        
        Console.WriteLine($"3 + 4 = {add(3, 4)}");
        Console.WriteLine($"3 * 4 = {multiply(3, 4)}");
        
        // No parameters
        Func<int> getRandomNumber = () => new Random().Next(100);
        Console.WriteLine($"Random: {getRandomNumber()}");
        
        // Statement lambda: (parameters) => { statements }
        Action<string> greet = name =>
        {
            string greeting = $"Hello, {name}!";
            Console.WriteLine(greeting);
        };
        
        greet("World");
    }
}`}
/>

## Lambda with Different Delegate Types

<CodeEditor 
  initialCode={`using System;

class Program
{
    static void Main()
    {
        // Action - no return value
        Action sayHi = () => Console.WriteLine("Hi!");
        Action<string> greet = name => Console.WriteLine($"Hello, {name}!");
        Action<string, int> repeat = (msg, times) =>
        {
            for (int i = 0; i < times; i++)
                Console.WriteLine(msg);
        };
        
        Console.WriteLine("=== Action ===");
        sayHi();
        greet("Alice");
        repeat("Echo!", 3);
        
        // Func - has return value
        Func<int> getRandom = () => new Random().Next(100);
        Func<int, bool> isEven = n => n % 2 == 0;
        Func<string, string> toUpper = s => s.ToUpper();
        Func<int, int, double> average = (a, b) => (a + b) / 2.0;
        
        Console.WriteLine("\\n=== Func ===");
        Console.WriteLine($"Random: {getRandom()}");
        Console.WriteLine($"Is 4 even? {isEven(4)}");
        Console.WriteLine($"Upper: {toUpper("hello")}");
        Console.WriteLine($"Average of 5,7: {average(5, 7)}");
        
        // Predicate - returns bool
        Predicate<int> isPositive = x => x > 0;
        Predicate<string> isEmpty = s => string.IsNullOrEmpty(s);
        
        Console.WriteLine("\\n=== Predicate ===");
        Console.WriteLine($"Is 5 positive? {isPositive(5)}");
        Console.WriteLine($"Is '' empty? {isEmpty("")}");
    }
}`}
/>

## Lambda with LINQ

<CodeEditor 
  initialCode={`using System;
using System.Linq;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        
        Console.WriteLine($"Numbers: {string.Join(", ", numbers)}");
        
        // Where - filter
        var evens = numbers.Where(n => n % 2 == 0);
        Console.WriteLine($"Evens: {string.Join(", ", evens)}");
        
        // Select - transform
        var squares = numbers.Select(n => n * n);
        Console.WriteLine($"Squares: {string.Join(", ", squares)}");
        
        // OrderBy / OrderByDescending
        var shuffled = new List<int> { 5, 2, 8, 1, 9, 3 };
        var sorted = shuffled.OrderBy(n => n);
        var descending = shuffled.OrderByDescending(n => n);
        Console.WriteLine($"Sorted: {string.Join(", ", sorted)}");
        Console.WriteLine($"Descending: {string.Join(", ", descending)}");
        
        // First, Last, Single
        var first = numbers.First(n => n > 5);
        var last = numbers.Last(n => n < 5);
        Console.WriteLine($"First > 5: {first}");
        Console.WriteLine($"Last < 5: {last}");
        
        // Any, All
        bool hasEven = numbers.Any(n => n % 2 == 0);
        bool allPositive = numbers.All(n => n > 0);
        Console.WriteLine($"Has even: {hasEven}");
        Console.WriteLine($"All positive: {allPositive}");
        
        // Count, Sum, Average
        int evenCount = numbers.Count(n => n % 2 == 0);
        int sum = numbers.Where(n => n % 2 == 0).Sum();
        double avg = numbers.Average();
        Console.WriteLine($"Even count: {evenCount}");
        Console.WriteLine($"Sum of evens: {sum}");
        Console.WriteLine($"Average: {avg}");
    }
}`}
/>

## Lambda with Objects

<CodeEditor 
  initialCode={`using System;
using System.Linq;
using System.Collections.Generic;

class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string City { get; set; }
}

class Program
{
    static void Main()
    {
        var people = new List<Person>
        {
            new Person { Name = "Alice", Age = 25, City = "NYC" },
            new Person { Name = "Bob", Age = 35, City = "LA" },
            new Person { Name = "Charlie", Age = 28, City = "NYC" },
            new Person { Name = "Diana", Age = 42, City = "Chicago" },
            new Person { Name = "Eve", Age = 31, City = "LA" }
        };
        
        // Filter by property
        Console.WriteLine("=== People from NYC ===");
        var fromNYC = people.Where(p => p.City == "NYC");
        foreach (var p in fromNYC)
        {
            Console.WriteLine($"  {p.Name}, {p.Age}");
        }
        
        // Order by property
        Console.WriteLine("\\n=== Ordered by Age ===");
        var byAge = people.OrderBy(p => p.Age);
        foreach (var p in byAge)
        {
            Console.WriteLine($"  {p.Name}: {p.Age}");
        }
        
        // Select specific property
        Console.WriteLine("\\n=== Just Names ===");
        var names = people.Select(p => p.Name);
        Console.WriteLine($"  {string.Join(", ", names)}");
        
        // Transform to new object
        Console.WriteLine("\\n=== Name and City ===");
        var summaries = people.Select(p => new { p.Name, p.City });
        foreach (var s in summaries)
        {
            Console.WriteLine($"  {s.Name} lives in {s.City}");
        }
        
        // Group by
        Console.WriteLine("\\n=== Grouped by City ===");
        var byCity = people.GroupBy(p => p.City);
        foreach (var group in byCity)
        {
            Console.WriteLine($"  {group.Key}: {string.Join(", ", group.Select(p => p.Name))}");
        }
        
        // Aggregate
        var oldest = people.OrderByDescending(p => p.Age).First();
        var avgAge = people.Average(p => p.Age);
        Console.WriteLine($"\\nOldest: {oldest.Name} ({oldest.Age})");
        Console.WriteLine($"Average age: {avgAge:F1}");
    }
}`}
/>

## Closures - Capturing Variables

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Lambda captures external variable
        int multiplier = 3;
        Func<int, int> multiply = x => x * multiplier;
        
        Console.WriteLine($"5 * {multiplier} = {multiply(5)}");
        
        // Change the captured variable
        multiplier = 10;
        Console.WriteLine($"5 * {multiplier} = {multiply(5)}");  // Uses new value!
        
        // Creating lambdas in a loop - common pitfall
        Console.WriteLine("\\n=== Loop Capture (Wrong) ===");
        var funcsWrong = new List<Func<int>>();
        for (int i = 0; i < 3; i++)
        {
            funcsWrong.Add(() => i);  // All capture the same 'i'
        }
        foreach (var f in funcsWrong)
        {
            Console.WriteLine(f());  // All print 3!
        }
        
        // Correct way - capture loop variable by value
        Console.WriteLine("\\n=== Loop Capture (Correct) ===");
        var funcsRight = new List<Func<int>>();
        for (int i = 0; i < 3; i++)
        {
            int captured = i;  // Create a copy
            funcsRight.Add(() => captured);
        }
        foreach (var f in funcsRight)
        {
            Console.WriteLine(f());  // Prints 0, 1, 2
        }
        
        // Counter using closure
        Console.WriteLine("\\n=== Counter with Closure ===");
        var counter = CreateCounter();
        Console.WriteLine(counter());  // 1
        Console.WriteLine(counter());  // 2
        Console.WriteLine(counter());  // 3
    }
    
    static Func<int> CreateCounter()
    {
        int count = 0;
        return () => ++count;  // Captures 'count'
    }
}`}
/>

## Lambda in Event Handlers

<CodeEditor 
  initialCode={`using System;

class Button
{
    public string Name { get; set; }
    public event EventHandler Clicked;
    
    public void Click()
    {
        Clicked?.Invoke(this, EventArgs.Empty);
    }
}

class Program
{
    static void Main()
    {
        var button1 = new Button { Name = "Submit" };
        var button2 = new Button { Name = "Cancel" };
        var button3 = new Button { Name = "Delete" };
        
        int clickCount = 0;
        
        // Lambda event handlers
        button1.Clicked += (sender, e) =>
        {
            clickCount++;
            Button btn = (Button)sender;
            Console.WriteLine($"{btn.Name} clicked! (Total clicks: {clickCount})");
        };
        
        button2.Clicked += (sender, e) =>
        {
            Console.WriteLine("Operation cancelled");
        };
        
        button3.Clicked += (sender, e) =>
        {
            Console.WriteLine("Are you sure you want to delete?");
        };
        
        // Simulate clicks
        button1.Click();
        button1.Click();
        button2.Click();
        button3.Click();
        button1.Click();
    }
}`}
/>

## Higher-Order Functions

Functions that take or return other functions:

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        var numbers = new List<int> { 1, 2, 3, 4, 5 };
        
        // ForEach with lambda
        Console.WriteLine("=== ForEach ===");
        numbers.ForEach(n => Console.Write($"{n} "));
        Console.WriteLine();
        
        // Custom Map function
        Console.WriteLine("\\n=== Custom Map ===");
        var doubled = Map(numbers, n => n * 2);
        Console.WriteLine($"Doubled: {string.Join(", ", doubled)}");
        
        // Custom Filter function
        Console.WriteLine("\\n=== Custom Filter ===");
        var evens = Filter(numbers, n => n % 2 == 0);
        Console.WriteLine($"Evens: {string.Join(", ", evens)}");
        
        // Custom Reduce function
        Console.WriteLine("\\n=== Custom Reduce ===");
        var sum = Reduce(numbers, 0, (acc, n) => acc + n);
        var product = Reduce(numbers, 1, (acc, n) => acc * n);
        Console.WriteLine($"Sum: {sum}");
        Console.WriteLine($"Product: {product}");
        
        // Function composition
        Console.WriteLine("\\n=== Function Composition ===");
        Func<int, int> addOne = x => x + 1;
        Func<int, int> double_ = x => x * 2;
        Func<int, int> square = x => x * x;
        
        var composed = Compose(addOne, Compose(double_, square));
        Console.WriteLine($"(5^2 * 2) + 1 = {composed(5)}");
    }
    
    // Higher-order function: Map
    static List<T> Map<T>(List<T> list, Func<T, T> transform)
    {
        var result = new List<T>();
        foreach (var item in list)
        {
            result.Add(transform(item));
        }
        return result;
    }
    
    // Higher-order function: Filter
    static List<T> Filter<T>(List<T> list, Func<T, bool> predicate)
    {
        var result = new List<T>();
        foreach (var item in list)
        {
            if (predicate(item))
            {
                result.Add(item);
            }
        }
        return result;
    }
    
    // Higher-order function: Reduce
    static T Reduce<T>(List<T> list, T initial, Func<T, T, T> accumulator)
    {
        T result = initial;
        foreach (var item in list)
        {
            result = accumulator(result, item);
        }
        return result;
    }
    
    // Function composition
    static Func<T, T> Compose<T>(Func<T, T> f, Func<T, T> g)
    {
        return x => f(g(x));
    }
}`}
/>

## Complete Example: Data Pipeline

<CodeEditor 
  initialCode={`using System;
using System.Linq;
using System.Collections.Generic;

class Order
{
    public int Id { get; set; }
    public string Customer { get; set; }
    public decimal Total { get; set; }
    public string Status { get; set; }
    public DateTime Date { get; set; }
}

class Program
{
    static void Main()
    {
        var orders = new List<Order>
        {
            new Order { Id = 1, Customer = "Alice", Total = 150, Status = "Shipped", Date = DateTime.Now.AddDays(-5) },
            new Order { Id = 2, Customer = "Bob", Total = 89, Status = "Pending", Date = DateTime.Now.AddDays(-2) },
            new Order { Id = 3, Customer = "Alice", Total = 250, Status = "Shipped", Date = DateTime.Now.AddDays(-10) },
            new Order { Id = 4, Customer = "Charlie", Total = 175, Status = "Cancelled", Date = DateTime.Now.AddDays(-1) },
            new Order { Id = 5, Customer = "Bob", Total = 320, Status = "Shipped", Date = DateTime.Now.AddDays(-7) },
            new Order { Id = 6, Customer = "Diana", Total = 95, Status = "Pending", Date = DateTime.Now.AddDays(-3) }
        };
        
        Console.WriteLine("=== All Orders ===");
        orders.ForEach(o => Console.WriteLine($"  #{o.Id} {o.Customer}: \\${'{'}o.Total{'}'} ({o.Status})"));
        
        // Pipeline: Filter -> Sort -> Transform -> Take
        Console.WriteLine("\\n=== Top 3 Shipped Orders (by Total) ===");
        var topShipped = orders
            .Where(o => o.Status == "Shipped")
            .OrderByDescending(o => o.Total)
            .Take(3)
            .Select(o => new { o.Customer, o.Total });
        
        foreach (var o in topShipped)
        {
            Console.WriteLine($"  {o.Customer}: \\${'{'}o.Total{'}'}");
        }
        
        // Aggregation
        Console.WriteLine("\\n=== Sales Summary ===");
        var shippedOrders = orders.Where(o => o.Status == "Shipped");
        Console.WriteLine($"  Shipped orders: {shippedOrders.Count()}");
        Console.WriteLine($"  Total revenue: \\${'{'}shippedOrders.Sum(o => o.Total){'}'}");
        Console.WriteLine($"  Average order: \\${'{'}shippedOrders.Average(o => o.Total):F2{'}'}");
        
        // Group and aggregate
        Console.WriteLine("\\n=== Revenue by Customer ===");
        var byCustomer = orders
            .Where(o => o.Status == "Shipped")
            .GroupBy(o => o.Customer)
            .Select(g => new 
            { 
                Customer = g.Key, 
                Total = g.Sum(o => o.Total),
                Count = g.Count()
            })
            .OrderByDescending(x => x.Total);
        
        foreach (var c in byCustomer)
        {
            Console.WriteLine($"  {c.Customer}: \\${'{'}c.Total{'}'} ({c.Count} orders)");
        }
        
        // Find with lambda
        Console.WriteLine("\\n=== Order Lookup ===");
        var bigOrders = orders.FindAll(o => o.Total > 200);
        Console.WriteLine($"Orders over \\$200: {string.Join(", ", bigOrders.Select(o => $"#{o.Id}"))}");
        
        var bobOrder = orders.Find(o => o.Customer == "Bob" && o.Status == "Shipped");
        Console.WriteLine($"Bob's shipped order: #{bobOrder?.Id}");
    }
}`}
/>

## Key Takeaways

- **Lambda expressions** are anonymous inline functions
- Use `=>` operator (expression lambda) or `=> { }` (statement lambda)
- Essential for **LINQ**, **events**, and **callbacks**
- Lambdas can **capture variables** from outer scope (closures)
- Use **Action** for void, **Func** for return values, **Predicate** for bool

## Lambda Syntax Cheat Sheet

| Syntax | Description | Example |
|--------|-------------|---------|
| `x => expression` | Single param, expression | `x => x * 2` |
| `(x, y) => expression` | Multiple params | `(a, b) => a + b` |
| `() => expression` | No params | `() => DateTime.Now` |
| `x => { statements }` | Statement body | `x => { return x * 2; }` |

## Best Practices

1. **Keep lambdas short** - extract complex logic to named methods
2. **Use meaningful parameter names** for complex lambdas
3. **Be careful with closures** - they capture by reference
4. **Prefer expression lambdas** when possible for readability
5. **Use method groups** when lambda just calls a method

## Next Module

You've completed Delegates & Events! Continue to **LINQ** for powerful data querying!
