---
title: "Delegates"
description: "Learn how to use delegates for type-safe function references"
order: 1
difficulty: "advanced"
tags: ["delegates", "callbacks", "function pointers"]
duration: "30 minutes"
---

# Delegates in C#

Delegates are type-safe function pointers that allow you to treat methods as objects. They're fundamental to events, callbacks, and functional programming in C#.

## What is a Delegate?

A delegate is a type that represents a reference to a method. It defines the signature (return type and parameters) that methods must match.

## Basic Delegate Syntax

<CodeEditor 
  initialCode={`using System;

// Declare a delegate type
delegate void MessageHandler(string message);

class Program
{
    // Methods that match the delegate signature
    static void PrintToConsole(string message)
    {
        Console.WriteLine($"Console: {message}");
    }
    
    static void PrintToUpper(string message)
    {
        Console.WriteLine($"UPPER: {message.ToUpper()}");
    }
    
    static void PrintWithTimestamp(string message)
    {
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {message}");
    }
    
    static void Main()
    {
        // Create delegate instances
        MessageHandler handler1 = PrintToConsole;
        MessageHandler handler2 = PrintToUpper;
        MessageHandler handler3 = PrintWithTimestamp;
        
        // Invoke delegates
        handler1("Hello World");
        handler2("Hello World");
        handler3("Hello World");
    }
}`}
/>

## Delegates with Return Values

<CodeEditor 
  initialCode={`using System;

// Delegate that returns a value
delegate int MathOperation(int a, int b);

class Program
{
    static int Add(int a, int b) => a + b;
    static int Subtract(int a, int b) => a - b;
    static int Multiply(int a, int b) => a * b;
    static int Divide(int a, int b) => b != 0 ? a / b : 0;
    
    static void Main()
    {
        // Create delegate instances
        MathOperation add = Add;
        MathOperation subtract = Subtract;
        MathOperation multiply = Multiply;
        MathOperation divide = Divide;
        
        int x = 20, y = 5;
        
        Console.WriteLine($"Operations on {x} and {y}:");
        Console.WriteLine($"Add: {add(x, y)}");
        Console.WriteLine($"Subtract: {subtract(x, y)}");
        Console.WriteLine($"Multiply: {multiply(x, y)}");
        Console.WriteLine($"Divide: {divide(x, y)}");
        
        // Store delegates in array
        MathOperation[] operations = { add, subtract, multiply, divide };
        string[] names = { "Add", "Sub", "Mul", "Div" };
        
        Console.WriteLine("\\nAll operations:");
        for (int i = 0; i < operations.Length; i++)
        {
            Console.WriteLine($"  {names[i]}: {operations[i](10, 3)}");
        }
    }
}`}
/>

## Multicast Delegates

Delegates can reference multiple methods:

<CodeEditor 
  initialCode={`using System;

delegate void NotifyHandler(string message);

class Program
{
    static void SendEmail(string message)
    {
        Console.WriteLine($"Email sent: {message}");
    }
    
    static void SendSMS(string message)
    {
        Console.WriteLine($"SMS sent: {message}");
    }
    
    static void LogToFile(string message)
    {
        Console.WriteLine($"Logged: {message}");
    }
    
    static void ShowPopup(string message)
    {
        Console.WriteLine($"Popup: {message}");
    }
    
    static void Main()
    {
        // Create multicast delegate using +=
        NotifyHandler notify = SendEmail;
        notify += SendSMS;
        notify += LogToFile;
        notify += ShowPopup;
        
        Console.WriteLine("=== Notifying all handlers ===");
        notify("Server is down!");
        
        // Remove a handler
        Console.WriteLine("\\n=== After removing SMS ===");
        notify -= SendSMS;
        notify("Server recovered!");
        
        // Check for null before invoking
        Console.WriteLine("\\n=== Safe invocation ===");
        notify?.Invoke("System update complete");
    }
}`}
/>

## Delegates as Parameters

Pass delegates to methods for callbacks:

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

delegate bool NumberFilter(int number);

class Program
{
    // Method that accepts a delegate
    static List<int> FilterNumbers(int[] numbers, NumberFilter filter)
    {
        List<int> result = new List<int>();
        foreach (int n in numbers)
        {
            if (filter(n))
            {
                result.Add(n);
            }
        }
        return result;
    }
    
    // Filter methods
    static bool IsEven(int n) => n % 2 == 0;
    static bool IsOdd(int n) => n % 2 != 0;
    static bool IsPositive(int n) => n > 0;
    static bool IsGreaterThan5(int n) => n > 5;
    
    static void Main()
    {
        int[] numbers = { -3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        
        Console.WriteLine($"Original: {string.Join(", ", numbers)}");
        
        var evens = FilterNumbers(numbers, IsEven);
        Console.WriteLine($"Even: {string.Join(", ", evens)}");
        
        var odds = FilterNumbers(numbers, IsOdd);
        Console.WriteLine($"Odd: {string.Join(", ", odds)}");
        
        var positives = FilterNumbers(numbers, IsPositive);
        Console.WriteLine($"Positive: {string.Join(", ", positives)}");
        
        var greaterThan5 = FilterNumbers(numbers, IsGreaterThan5);
        Console.WriteLine($"Greater than 5: {string.Join(", ", greaterThan5)}");
    }
}`}
/>

## Built-in Delegate Types

C# provides generic delegates: `Action`, `Func`, and `Predicate`:

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Action - void return, up to 16 parameters
        Action sayHello = () => Console.WriteLine("Hello!");
        Action<string> greet = name => Console.WriteLine($"Hello, {name}!");
        Action<string, int> greetTimes = (name, times) =>
        {
            for (int i = 0; i < times; i++)
                Console.WriteLine($"Hello, {name}!");
        };
        
        Console.WriteLine("=== Action ===");
        sayHello();
        greet("Alice");
        greetTimes("Bob", 3);
        
        // Func - has return value, last type is return type
        Func<int> getRandomNumber = () => new Random().Next(100);
        Func<int, int> square = x => x * x;
        Func<int, int, int> add = (a, b) => a + b;
        Func<string, string> toUpper = s => s.ToUpper();
        
        Console.WriteLine("\\n=== Func ===");
        Console.WriteLine($"Random: {getRandomNumber()}");
        Console.WriteLine($"Square of 5: {square(5)}");
        Console.WriteLine($"3 + 4 = {add(3, 4)}");
        Console.WriteLine($"Upper: {toUpper("hello")}");
        
        // Predicate - returns bool, single parameter
        Predicate<int> isPositive = n => n > 0;
        Predicate<string> isNullOrEmpty = s => string.IsNullOrEmpty(s);
        
        Console.WriteLine("\\n=== Predicate ===");
        Console.WriteLine($"Is 5 positive? {isPositive(5)}");
        Console.WriteLine($"Is -3 positive? {isPositive(-3)}");
        Console.WriteLine($"Is '' empty? {isNullOrEmpty("")}");
        
        // Using Predicate with List.FindAll
        var numbers = new List<int> { 1, -2, 3, -4, 5, -6 };
        var positives = numbers.FindAll(isPositive);
        Console.WriteLine($"Positives: {string.Join(", ", positives)}");
    }
}`}
/>

## Delegates with Instance Methods

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

delegate void ProcessItem(string item);

class Logger
{
    public string Prefix { get; set; }
    
    public Logger(string prefix)
    {
        Prefix = prefix;
    }
    
    public void Log(string item)
    {
        Console.WriteLine($"[{Prefix}] {item}");
    }
}

class Processor
{
    private List<string> items = new List<string>();
    private ProcessItem processDelegate;
    
    public void AddItem(string item) => items.Add(item);
    
    public void SetProcessor(ProcessItem processor)
    {
        processDelegate = processor;
    }
    
    public void ProcessAll()
    {
        foreach (var item in items)
        {
            processDelegate?.Invoke(item);
        }
    }
}

class Program
{
    static void Main()
    {
        // Create instances with their own state
        Logger infoLogger = new Logger("INFO");
        Logger errorLogger = new Logger("ERROR");
        
        Processor processor = new Processor();
        processor.AddItem("Item 1");
        processor.AddItem("Item 2");
        processor.AddItem("Item 3");
        
        // Use instance method as delegate
        Console.WriteLine("=== Info Logger ===");
        processor.SetProcessor(infoLogger.Log);
        processor.ProcessAll();
        
        Console.WriteLine("\\n=== Error Logger ===");
        processor.SetProcessor(errorLogger.Log);
        processor.ProcessAll();
        
        // Multicast with instance methods
        Console.WriteLine("\\n=== Both Loggers ===");
        ProcessItem combined = infoLogger.Log;
        combined += errorLogger.Log;
        
        combined("Combined message");
    }
}`}
/>

## Callback Pattern

<CodeEditor 
  initialCode={`using System;
using System.Threading;

class FileDownloader
{
    public delegate void DownloadCompleted(string filename, bool success);
    public delegate void ProgressUpdated(int percentage);
    
    public void Download(string url, DownloadCompleted onComplete, ProgressUpdated onProgress = null)
    {
        Console.WriteLine($"Starting download: {url}");
        
        // Simulate download progress
        for (int i = 0; i <= 100; i += 20)
        {
            Thread.Sleep(200);  // Simulate work
            onProgress?.Invoke(i);
        }
        
        // Simulate completion
        string filename = "file_" + new Random().Next(1000) + ".zip";
        bool success = new Random().Next(10) > 1;  // 90% success rate
        
        onComplete(filename, success);
    }
}

class Program
{
    static void OnDownloadComplete(string filename, bool success)
    {
        if (success)
            Console.WriteLine($"\\nDownload complete: {filename}");
        else
            Console.WriteLine($"\\nDownload failed: {filename}");
    }
    
    static void OnProgressUpdate(int percentage)
    {
        Console.Write($"\\rProgress: {percentage}%");
    }
    
    static void Main()
    {
        FileDownloader downloader = new FileDownloader();
        
        Console.WriteLine("=== Download with callbacks ===\\n");
        
        downloader.Download(
            "https://example.com/file.zip",
            OnDownloadComplete,
            OnProgressUpdate
        );
        
        Console.WriteLine("\\n\\n=== Download with lambda ===\\n");
        
        downloader.Download(
            "https://example.com/data.zip",
            (file, ok) => Console.WriteLine($"\\nResult: {file} - {(ok ? "OK" : "Failed")}"),
            p => Console.Write($"\\r[{new string('=', p / 5)}{new string(' ', 20 - p / 5)}] {p}%")
        );
    }
}`}
/>

## Complete Example: Event System

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

delegate void GameEventHandler(string eventName, object data);

class EventManager
{
    private Dictionary<string, List<GameEventHandler>> handlers = 
        new Dictionary<string, List<GameEventHandler>>();
    
    public void Subscribe(string eventName, GameEventHandler handler)
    {
        if (!handlers.ContainsKey(eventName))
        {
            handlers[eventName] = new List<GameEventHandler>();
        }
        handlers[eventName].Add(handler);
        Console.WriteLine($"Subscribed to '{eventName}'");
    }
    
    public void Unsubscribe(string eventName, GameEventHandler handler)
    {
        if (handlers.ContainsKey(eventName))
        {
            handlers[eventName].Remove(handler);
            Console.WriteLine($"Unsubscribed from '{eventName}'");
        }
    }
    
    public void Emit(string eventName, object data = null)
    {
        Console.WriteLine($"\\n>>> Emitting '{eventName}'");
        
        if (handlers.ContainsKey(eventName))
        {
            foreach (var handler in handlers[eventName])
            {
                handler(eventName, data);
            }
        }
    }
}

class Player
{
    public string Name { get; set; }
    public int Health { get; set; } = 100;
    
    public void OnDamage(string eventName, object data)
    {
        int damage = (int)data;
        Health -= damage;
        Console.WriteLine($"  {Name} took {damage} damage. Health: {Health}");
    }
    
    public void OnHeal(string eventName, object data)
    {
        int amount = (int)data;
        Health += amount;
        Console.WriteLine($"  {Name} healed {amount}. Health: {Health}");
    }
}

class UI
{
    public void OnScoreChanged(string eventName, object data)
    {
        Console.WriteLine($"  [UI] Score updated: {data}");
    }
    
    public void OnGameEvent(string eventName, object data)
    {
        Console.WriteLine($"  [UI] Event notification: {eventName}");
    }
}

class Program
{
    static void Main()
    {
        EventManager events = new EventManager();
        Player player = new Player { Name = "Hero" };
        UI ui = new UI();
        
        // Subscribe to events
        events.Subscribe("damage", player.OnDamage);
        events.Subscribe("heal", player.OnHeal);
        events.Subscribe("score", ui.OnScoreChanged);
        events.Subscribe("damage", ui.OnGameEvent);
        events.Subscribe("heal", ui.OnGameEvent);
        
        // Emit events
        events.Emit("damage", 25);
        events.Emit("score", 100);
        events.Emit("heal", 15);
        events.Emit("damage", 10);
        
        Console.WriteLine($"\\nFinal health: {player.Health}");
    }
}`}
/>

## Key Takeaways

- **Delegates** are type-safe function references
- They can reference **static** or **instance** methods
- **Multicast delegates** can invoke multiple methods
- Use **Action**, **Func**, and **Predicate** for common patterns
- Delegates enable the **callback pattern**
- They're the foundation for **events** in C#

## Delegate Cheat Sheet

| Type | Description | Example |
|------|-------------|---------|
| `Action` | No return, no params | `Action a = () => {};` |
| `Action<T>` | No return, 1 param | `Action<int> a = x => {};` |
| `Func<TResult>` | Returns T, no params | `Func<int> f = () => 5;` |
| `Func<T,TResult>` | Takes T, returns TResult | `Func<int,int> f = x => x*2;` |
| `Predicate<T>` | Takes T, returns bool | `Predicate<int> p = x => x > 0;` |

## Next Steps

Next lesson: **Events** - Learn how to use the event pattern for loose coupling!
