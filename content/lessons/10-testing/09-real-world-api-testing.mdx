---
title: "Real-World API Integration Testing"
description: "Complete guide to testing real APIs with authentication, CRUD operations, and error handling"
order: 9
difficulty: "advanced"
tags: ["api", "integration", "authentication", "crud", "real-world"]
duration: "60 minutes"
---

# Real-World API Integration Testing

Let's put everything together with complete, real-world API testing scenarios. We'll test a real API with authentication, full CRUD operations, and proper error handling.

## Prerequisites

‚ö†Ô∏è **MOST ADVANCED LESSON** - This is the culmination of all previous lessons. Make sure you're comfortable with all prerequisites!

**Required lessons:**
- ‚úÖ 01-fundamentals (complete section)
- ‚úÖ 02-oop-basics (all 6 lessons)
- ‚úÖ 02-oop-basics/06-dependency-injection (DI pattern)
- ‚úÖ 03-oop-advanced/03-interfaces
- ‚úÖ 03-oop-advanced/04-abstract-classes
- ‚úÖ 06-modern-csharp/01-async-await (**CRITICAL**)
- ‚úÖ 08-error-handling (both lessons - exception handling)
- ‚úÖ 09-generics/01-generic-classes (generic methods and classes)
- ‚úÖ 11-working-with-json/01-json-basics (**CRITICAL**)
- ‚úÖ 11-working-with-json/02-json-serialization (**CRITICAL**)
- ‚úÖ 10-testing/03-writing-first-tests
- ‚úÖ 10-testing/07-http-client-testing
- ‚úÖ 10-testing/08-api-mocking-moq

**What you need to know:**
- Complete async/await mastery
- JSON serialization/deserialization with System.Text.Json
- Generic types and methods
- Dependency injection and interfaces
- Error handling with try/catch
- HTTP concepts (headers, auth, status codes)
- xUnit testing patterns
- IDisposable pattern for cleanup

‚è±Ô∏è **If starting from scratch:** Complete fundamentals + OOP + modern C# + async + JSON + testing = ~15-20 hours total, then return here.

**üí° RECOMMENDATION:** This lesson brings together ALL concepts from the platform. Make sure you're comfortable with:
1. Async/await (lesson 06-modern-csharp/01)
2. JSON (lessons 11-working-with-json/01-02)
3. Dependency injection (lesson 02-oop-basics/06)
4. HTTP client (lesson 10-testing/07)

## Project Setup

### Create the Project

```bash
# Create solution
mkdir RealWorldApiTests
cd RealWorldApiTests
dotnet new sln -n RealWorldApiTests

# Create test project
dotnet new xunit -n ApiIntegrationTests
dotnet sln add ApiIntegrationTests

# Add packages
cd ApiIntegrationTests
dotnet add package Microsoft.NET.Test.Sdk
dotnet add package xunit
dotnet add package xunit.runner.visualstudio
dotnet add package Newtonsoft.Json
dotnet add package FluentAssertions
dotnet add package RestSharp
```

### Project Structure

```
RealWorldApiTests/
‚îú‚îÄ‚îÄ ApiIntegrationTests/
‚îÇ   ‚îú‚îÄ‚îÄ ApiIntegrationTests.csproj
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Post.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ApiResponse.cs
‚îÇ   ‚îú‚îÄ‚îÄ Clients/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ JsonPlaceholderClient.cs
‚îÇ   ‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserApiTests.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PostApiTests.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WorkflowTests.cs
‚îÇ   ‚îî‚îÄ‚îÄ Fixtures/
‚îÇ       ‚îî‚îÄ‚îÄ ApiTestFixture.cs
```

## Model Classes

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

// User model - matches JSONPlaceholder API
public class User
{
    [JsonPropertyName("id")]
    public int Id { get; set; }
    
    [JsonPropertyName("name")]
    public string Name { get; set; }
    
    [JsonPropertyName("username")]
    public string Username { get; set; }
    
    [JsonPropertyName("email")]
    public string Email { get; set; }
    
    [JsonPropertyName("phone")]
    public string Phone { get; set; }
    
    [JsonPropertyName("website")]
    public string Website { get; set; }
    
    [JsonPropertyName("address")]
    public Address Address { get; set; }
    
    [JsonPropertyName("company")]
    public Company Company { get; set; }
}

public class Address
{
    [JsonPropertyName("street")]
    public string Street { get; set; }
    
    [JsonPropertyName("suite")]
    public string Suite { get; set; }
    
    [JsonPropertyName("city")]
    public string City { get; set; }
    
    [JsonPropertyName("zipcode")]
    public string Zipcode { get; set; }
    
    [JsonPropertyName("geo")]
    public Geo Geo { get; set; }
}

public class Geo
{
    [JsonPropertyName("lat")]
    public string Lat { get; set; }
    
    [JsonPropertyName("lng")]
    public string Lng { get; set; }
}

public class Company
{
    [JsonPropertyName("name")]
    public string Name { get; set; }
    
    [JsonPropertyName("catchPhrase")]
    public string CatchPhrase { get; set; }
    
    [JsonPropertyName("bs")]
    public string Bs { get; set; }
}

// Post model
public class Post
{
    [JsonPropertyName("id")]
    public int Id { get; set; }
    
    [JsonPropertyName("userId")]
    public int UserId { get; set; }
    
    [JsonPropertyName("title")]
    public string Title { get; set; }
    
    [JsonPropertyName("body")]
    public string Body { get; set; }
}

// Comment model
public class Comment
{
    [JsonPropertyName("id")]
    public int Id { get; set; }
    
    [JsonPropertyName("postId")]
    public int PostId { get; set; }
    
    [JsonPropertyName("name")]
    public string Name { get; set; }
    
    [JsonPropertyName("email")]
    public string Email { get; set; }
    
    [JsonPropertyName("body")]
    public string Body { get; set; }
}

// Create request models
public class CreatePostRequest
{
    [JsonPropertyName("userId")]
    public int UserId { get; set; }
    
    [JsonPropertyName("title")]
    public string Title { get; set; }
    
    [JsonPropertyName("body")]
    public string Body { get; set; }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("API Models defined for JSONPlaceholder API");
        Console.WriteLine("- User (with Address, Company)");
        Console.WriteLine("- Post");
        Console.WriteLine("- Comment");
    }
}`}
/>

## Reusable API Client

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

public class ApiResponse<T>
{
    public bool IsSuccess { get; set; }
    public HttpStatusCode StatusCode { get; set; }
    public T Data { get; set; }
    public string RawContent { get; set; }
    public string ErrorMessage { get; set; }
    public long ResponseTimeMs { get; set; }
    public Dictionary<string, string> Headers { get; set; } = new();
}

public class JsonPlaceholderClient : IDisposable
{
    private readonly HttpClient _client;
    private readonly JsonSerializerOptions _jsonOptions;
    private const string BaseUrl = "https://jsonplaceholder.typicode.com/";
    
    public JsonPlaceholderClient()
    {
        _client = new HttpClient
        {
            BaseAddress = new Uri(BaseUrl),
            Timeout = TimeSpan.FromSeconds(30)
        };
        
        _client.DefaultRequestHeaders.Add("Accept", "application/json");
        _client.DefaultRequestHeaders.Add("User-Agent", "CSharpApiTests/1.0");
        
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }
    
    // GET request
    public async Task<ApiResponse<T>> GetAsync<T>(string endpoint)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var response = await _client.GetAsync(endpoint);
            stopwatch.Stop();
            
            return await ProcessResponse<T>(response, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new ApiResponse<T>
            {
                IsSuccess = false,
                ErrorMessage = ex.Message,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
    }
    
    // POST request
    public async Task<ApiResponse<T>> PostAsync<T>(string endpoint, object data)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var json = JsonSerializer.Serialize(data, _jsonOptions);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _client.PostAsync(endpoint, content);
            stopwatch.Stop();
            
            return await ProcessResponse<T>(response, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new ApiResponse<T>
            {
                IsSuccess = false,
                ErrorMessage = ex.Message,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
    }
    
    // PUT request
    public async Task<ApiResponse<T>> PutAsync<T>(string endpoint, object data)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var json = JsonSerializer.Serialize(data, _jsonOptions);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _client.PutAsync(endpoint, content);
            stopwatch.Stop();
            
            return await ProcessResponse<T>(response, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new ApiResponse<T>
            {
                IsSuccess = false,
                ErrorMessage = ex.Message,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
    }
    
    // PATCH request
    public async Task<ApiResponse<T>> PatchAsync<T>(string endpoint, object data)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var json = JsonSerializer.Serialize(data, _jsonOptions);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            var request = new HttpRequestMessage(HttpMethod.Patch, endpoint) { Content = content };
            
            var response = await _client.SendAsync(request);
            stopwatch.Stop();
            
            return await ProcessResponse<T>(response, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new ApiResponse<T>
            {
                IsSuccess = false,
                ErrorMessage = ex.Message,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
    }
    
    // DELETE request
    public async Task<ApiResponse<bool>> DeleteAsync(string endpoint)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var response = await _client.DeleteAsync(endpoint);
            stopwatch.Stop();
            
            return new ApiResponse<bool>
            {
                IsSuccess = response.IsSuccessStatusCode,
                StatusCode = response.StatusCode,
                Data = response.IsSuccessStatusCode,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new ApiResponse<bool>
            {
                IsSuccess = false,
                ErrorMessage = ex.Message,
                ResponseTimeMs = stopwatch.ElapsedMilliseconds
            };
        }
    }
    
    private async Task<ApiResponse<T>> ProcessResponse<T>(HttpResponseMessage response, long responseTime)
    {
        var result = new ApiResponse<T>
        {
            IsSuccess = response.IsSuccessStatusCode,
            StatusCode = response.StatusCode,
            ResponseTimeMs = responseTime
        };
        
        result.RawContent = await response.Content.ReadAsStringAsync();
        
        // Capture headers
        foreach (var header in response.Headers)
        {
            result.Headers[header.Key] = string.Join(", ", header.Value);
        }
        
        if (response.IsSuccessStatusCode && !string.IsNullOrEmpty(result.RawContent))
        {
            try
            {
                result.Data = JsonSerializer.Deserialize<T>(result.RawContent, _jsonOptions);
            }
            catch (JsonException ex)
            {
                result.ErrorMessage = $"JSON Parse Error: {ex.Message}";
            }
        }
        else if (!response.IsSuccessStatusCode)
        {
            result.ErrorMessage = result.RawContent;
        }
        
        return result;
    }
    
    public void Dispose()
    {
        _client.Dispose();
    }
}

class Program
{
    static async Task Main()
    {
        using var client = new JsonPlaceholderClient();
        
        Console.WriteLine("=== Testing API Client ===\\n");
        
        // Test GET
        var response = await client.GetAsync<User>("users/1");
        Console.WriteLine($"GET /users/1");
        Console.WriteLine($"  Status: {response.StatusCode}");
        Console.WriteLine($"  Response Time: {response.ResponseTimeMs}ms");
        Console.WriteLine($"  User: {response.Data?.Name}\\n");
        
        // Test POST
        var newPost = new { title = "Test", body = "Content", userId = 1 };
        var postResponse = await client.PostAsync<Post>("posts", newPost);
        Console.WriteLine($"POST /posts");
        Console.WriteLine($"  Status: {postResponse.StatusCode}");
        Console.WriteLine($"  Created ID: {postResponse.Data?.Id}");
    }
}`}
/>

## Comprehensive CRUD Tests

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Xunit;

public class Post
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string Title { get; set; }
    public string Body { get; set; }
}

public class PostApiTests : IDisposable
{
    private readonly JsonPlaceholderClient _client;
    
    public PostApiTests()
    {
        _client = new JsonPlaceholderClient();
    }
    
    public void Dispose()
    {
        _client.Dispose();
    }
    
    // ============ GET Tests ============
    
    [Fact]
    public async Task GetAllPosts_ReturnsListOf100Posts()
    {
        // Act
        var response = await _client.GetAsync<List<Post>>("posts");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
        Assert.NotNull(response.Data);
        Assert.Equal(100, response.Data.Count);
        Assert.True(response.ResponseTimeMs < 5000, "Response too slow");
    }
    
    [Theory]
    [InlineData(1)]
    [InlineData(50)]
    [InlineData(100)]
    public async Task GetPostById_ValidId_ReturnsCorrectPost(int postId)
    {
        // Act
        var response = await _client.GetAsync<Post>($"posts/{postId}");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
        Assert.NotNull(response.Data);
        Assert.Equal(postId, response.Data.Id);
        Assert.False(string.IsNullOrEmpty(response.Data.Title));
        Assert.False(string.IsNullOrEmpty(response.Data.Body));
        Assert.True(response.Data.UserId > 0);
    }
    
    [Fact]
    public async Task GetPostById_InvalidId_ReturnsNotFound()
    {
        // Act
        var response = await _client.GetAsync<Post>("posts/999999");
        
        // Assert
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }
    
    [Theory]
    [InlineData(1, 5)]   // User 1 has posts
    [InlineData(5, 10)]  // User 5 has posts
    public async Task GetPostsByUserId_ReturnsUserPosts(int userId, int expectedMinCount)
    {
        // Act
        var response = await _client.GetAsync<List<Post>>($"posts?userId={userId}");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.NotNull(response.Data);
        Assert.True(response.Data.Count >= expectedMinCount);
        Assert.All(response.Data, p => Assert.Equal(userId, p.UserId));
    }
    
    // ============ POST Tests (Create) ============
    
    [Fact]
    public async Task CreatePost_ValidData_ReturnsCreatedPost()
    {
        // Arrange
        var newPost = new
        {
            title = "Integration Test Post",
            body = "This post was created during automated testing",
            userId = 1
        };
        
        // Act
        var response = await _client.PostAsync<Post>("posts", newPost);
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(HttpStatusCode.Created, response.StatusCode);
        Assert.NotNull(response.Data);
        Assert.True(response.Data.Id > 0);
        Assert.Equal(newPost.title, response.Data.Title);
        Assert.Equal(newPost.body, response.Data.Body);
        Assert.Equal(newPost.userId, response.Data.UserId);
    }
    
    [Theory]
    [InlineData("Short", "Body")]
    [InlineData("A Very Long Title That Contains Many Words", "Short body")]
    [InlineData("Special Characters: @#$%^&*()", "Body with\nnewlines\nand\ttabs")]
    public async Task CreatePost_VariousTitles_Success(string title, string body)
    {
        // Arrange
        var newPost = new { title, body, userId = 1 };
        
        // Act
        var response = await _client.PostAsync<Post>("posts", newPost);
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(title, response.Data.Title);
    }
    
    // ============ PUT Tests (Full Update) ============
    
    [Fact]
    public async Task UpdatePost_ValidData_ReturnsUpdatedPost()
    {
        // Arrange
        var updatedPost = new
        {
            id = 1,
            title = "Updated Title",
            body = "Updated body content",
            userId = 1
        };
        
        // Act
        var response = await _client.PutAsync<Post>("posts/1", updatedPost);
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
        Assert.Equal("Updated Title", response.Data.Title);
        Assert.Equal("Updated body content", response.Data.Body);
    }
    
    // ============ PATCH Tests (Partial Update) ============
    
    [Fact]
    public async Task PatchPost_TitleOnly_UpdatesOnlyTitle()
    {
        // Arrange
        var partialUpdate = new { title = "Patched Title Only" };
        
        // Act
        var response = await _client.PatchAsync<Post>("posts/1", partialUpdate);
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal("Patched Title Only", response.Data.Title);
        // Body should remain unchanged (but JSONPlaceholder might not fully support this)
    }
    
    // ============ DELETE Tests ============
    
    [Fact]
    public async Task DeletePost_ValidId_ReturnsSuccess()
    {
        // Act
        var response = await _client.DeleteAsync("posts/1");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }
    
    // ============ Performance Tests ============
    
    [Fact]
    public async Task GetPost_ResponseTime_UnderThreshold()
    {
        // Act
        var response = await _client.GetAsync<Post>("posts/1");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.True(response.ResponseTimeMs < 2000, 
            $"Response took {response.ResponseTimeMs}ms, expected < 2000ms");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Run tests with: dotnet test");
    }
}`}
/>

## User API Tests

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Xunit;

public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public string Phone { get; set; }
    public string Website { get; set; }
    public Address Address { get; set; }
    public Company Company { get; set; }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string Zipcode { get; set; }
}

public class Company
{
    public string Name { get; set; }
}

public class UserApiTests : IDisposable
{
    private readonly JsonPlaceholderClient _client;
    
    public UserApiTests()
    {
        _client = new JsonPlaceholderClient();
    }
    
    public void Dispose() => _client.Dispose();
    
    [Fact]
    public async Task GetAllUsers_Returns10Users()
    {
        // Act
        var response = await _client.GetAsync<List<User>>("users");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.Equal(10, response.Data.Count);
    }
    
    [Fact]
    public async Task GetUser_ValidId_ReturnsCompleteUser()
    {
        // Act
        var response = await _client.GetAsync<User>("users/1");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.NotNull(response.Data);
        
        // Verify all required fields
        Assert.Equal(1, response.Data.Id);
        Assert.False(string.IsNullOrEmpty(response.Data.Name));
        Assert.False(string.IsNullOrEmpty(response.Data.Username));
        Assert.False(string.IsNullOrEmpty(response.Data.Email));
        Assert.Contains("@", response.Data.Email);  // Valid email format
        
        // Verify nested objects
        Assert.NotNull(response.Data.Address);
        Assert.False(string.IsNullOrEmpty(response.Data.Address.City));
        
        Assert.NotNull(response.Data.Company);
        Assert.False(string.IsNullOrEmpty(response.Data.Company.Name));
    }
    
    [Theory]
    [InlineData(1, "Leanne Graham")]
    [InlineData(2, "Ervin Howell")]
    [InlineData(3, "Clementine Bauch")]
    public async Task GetUser_ById_ReturnsCorrectName(int userId, string expectedName)
    {
        // Act
        var response = await _client.GetAsync<User>($"users/{userId}");
        
        // Assert
        Assert.Equal(expectedName, response.Data.Name);
    }
    
    [Fact]
    public async Task GetUser_InvalidId_ReturnsNotFound()
    {
        // Act
        var response = await _client.GetAsync<User>("users/99999");
        
        // Assert
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }
    
    [Fact]
    public async Task GetUsers_AllHaveValidEmails()
    {
        // Act
        var response = await _client.GetAsync<List<User>>("users");
        
        // Assert
        Assert.All(response.Data, user =>
        {
            Assert.NotNull(user.Email);
            Assert.Contains("@", user.Email);
            Assert.Contains(".", user.Email);
        });
    }
    
    [Fact]
    public async Task GetUsers_AllHaveUniqueIds()
    {
        // Act
        var response = await _client.GetAsync<List<User>>("users");
        
        // Assert
        var ids = response.Data.Select(u => u.Id).ToList();
        var uniqueIds = ids.Distinct().ToList();
        Assert.Equal(ids.Count, uniqueIds.Count);
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("User API Tests");
    }
}`}
/>

## Testing Related Resources

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Xunit;

public class Comment
{
    public int Id { get; set; }
    public int PostId { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string Body { get; set; }
}

public class Todo
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public string Title { get; set; }
    public bool Completed { get; set; }
}

public class RelatedResourceTests : IDisposable
{
    private readonly JsonPlaceholderClient _client;
    
    public RelatedResourceTests()
    {
        _client = new JsonPlaceholderClient();
    }
    
    public void Dispose() => _client.Dispose();
    
    // Test nested resources: GET /posts/1/comments
    [Fact]
    public async Task GetPostComments_ReturnsCommentsForPost()
    {
        // Act
        var response = await _client.GetAsync<List<Comment>>("posts/1/comments");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.NotNull(response.Data);
        Assert.True(response.Data.Count > 0);
        
        // All comments should belong to post 1
        Assert.All(response.Data, c => Assert.Equal(1, c.PostId));
    }
    
    // Test query parameter filtering
    [Fact]
    public async Task GetCommentsByPostId_QueryParam_Works()
    {
        // Act
        var response = await _client.GetAsync<List<Comment>>("comments?postId=1");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.All(response.Data, c => Assert.Equal(1, c.PostId));
    }
    
    // Test user's posts
    [Fact]
    public async Task GetUserPosts_ReturnsUsersPosts()
    {
        // Arrange
        int userId = 1;
        
        // Act
        var response = await _client.GetAsync<List<Post>>("users/1/posts");
        
        // Assert - JSONPlaceholder may not support this exact route
        // Fallback to query param version
        if (!response.IsSuccess)
        {
            response = await _client.GetAsync<List<Post>>($"posts?userId={userId}");
        }
        
        Assert.True(response.IsSuccess);
        Assert.All(response.Data, p => Assert.Equal(userId, p.UserId));
    }
    
    // Test user's todos
    [Fact]
    public async Task GetUserTodos_ReturnsUsersTodos()
    {
        // Act
        var response = await _client.GetAsync<List<Todo>>("todos?userId=1");
        
        // Assert
        Assert.True(response.IsSuccess);
        Assert.True(response.Data.Count > 0);
        Assert.All(response.Data, t => Assert.Equal(1, t.UserId));
    }
    
    // Test completed vs incomplete todos
    [Fact]
    public async Task GetTodos_ContainsBothCompletedAndIncomplete()
    {
        // Act
        var response = await _client.GetAsync<List<Todo>>("todos");
        
        // Assert
        Assert.True(response.IsSuccess);
        
        var completed = response.Data.Where(t => t.Completed).ToList();
        var incomplete = response.Data.Where(t => !t.Completed).ToList();
        
        Assert.True(completed.Count > 0, "Should have some completed todos");
        Assert.True(incomplete.Count > 0, "Should have some incomplete todos");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Related Resources Tests");
    }
}`}
/>

## End-to-End Workflow Tests

<CodeEditor
  initialCode={`using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Xunit;

public class WorkflowTests : IDisposable
{
    private readonly JsonPlaceholderClient _client;
    
    public WorkflowTests()
    {
        _client = new JsonPlaceholderClient();
    }
    
    public void Dispose() => _client.Dispose();
    
    [Fact]
    public async Task CompletePostWorkflow_CreateReadUpdateDelete()
    {
        // ============ CREATE ============
        Console.WriteLine("Step 1: Create Post");
        var createData = new
        {
            title = "E2E Test Post",
            body = "Created during end-to-end testing",
            userId = 1
        };
        
        var createResponse = await _client.PostAsync<Post>("posts", createData);
        
        Assert.True(createResponse.IsSuccess, "Create failed");
        Assert.Equal(HttpStatusCode.Created, createResponse.StatusCode);
        
        int newPostId = createResponse.Data.Id;
        Assert.True(newPostId > 0, "Should have received new ID");
        Console.WriteLine($"  Created post with ID: {newPostId}");
        
        // ============ READ ============
        Console.WriteLine("\\nStep 2: Read Created Post");
        // Note: JSONPlaceholder doesn't actually persist, so we read post 1 instead
        var readResponse = await _client.GetAsync<Post>("posts/1");
        
        Assert.True(readResponse.IsSuccess, "Read failed");
        Assert.NotNull(readResponse.Data);
        Console.WriteLine($"  Read post: {readResponse.Data.Title}");
        
        // ============ UPDATE ============
        Console.WriteLine("\\nStep 3: Update Post");
        var updateData = new
        {
            id = 1,
            title = "Updated E2E Test Post",
            body = "This post was updated during testing",
            userId = 1
        };
        
        var updateResponse = await _client.PutAsync<Post>("posts/1", updateData);
        
        Assert.True(updateResponse.IsSuccess, "Update failed");
        Assert.Equal("Updated E2E Test Post", updateResponse.Data.Title);
        Console.WriteLine($"  Updated title to: {updateResponse.Data.Title}");
        
        // ============ DELETE ============
        Console.WriteLine("\\nStep 4: Delete Post");
        var deleteResponse = await _client.DeleteAsync("posts/1");
        
        Assert.True(deleteResponse.IsSuccess, "Delete failed");
        Console.WriteLine($"  Deleted successfully");
        
        Console.WriteLine("\\n‚úì Complete CRUD workflow passed!");
    }
    
    [Fact]
    public async Task UserPostsWorkflow_GetUserAndTheirPosts()
    {
        // Step 1: Get a user
        Console.WriteLine("Step 1: Get User");
        var userResponse = await _client.GetAsync<User>("users/1");
        
        Assert.True(userResponse.IsSuccess);
        var user = userResponse.Data;
        Console.WriteLine($"  Found user: {user.Name}");
        
        // Step 2: Get user's posts
        Console.WriteLine("\\nStep 2: Get User's Posts");
        var postsResponse = await _client.GetAsync<List<Post>>($"posts?userId={user.Id}");
        
        Assert.True(postsResponse.IsSuccess);
        var posts = postsResponse.Data;
        Console.WriteLine($"  Found {posts.Count} posts");
        
        // Step 3: Get comments for first post
        if (posts.Count > 0)
        {
            Console.WriteLine("\\nStep 3: Get Comments for First Post");
            var commentsResponse = await _client.GetAsync<List<Comment>>(
                $"comments?postId={posts[0].Id}");
            
            Assert.True(commentsResponse.IsSuccess);
            Console.WriteLine($"  Found {commentsResponse.Data.Count} comments");
        }
        
        Console.WriteLine("\\n‚úì User posts workflow passed!");
    }
    
    [Fact]
    public async Task BatchOperations_MultipleCreates()
    {
        Console.WriteLine("Creating multiple posts...");
        
        var tasks = new List<Task<ApiResponse<Post>>>();
        
        for (int i = 1; i <= 5; i++)
        {
            var post = new { title = $"Batch Post {i}", body = $"Body {i}", userId = 1 };
            tasks.Add(_client.PostAsync<Post>("posts", post));
        }
        
        var responses = await Task.WhenAll(tasks);
        
        // Verify all succeeded
        Assert.All(responses, r =>
        {
            Assert.True(r.IsSuccess);
            Assert.Equal(HttpStatusCode.Created, r.StatusCode);
        });
        
        Console.WriteLine($"‚úì Created {responses.Length} posts successfully");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Run workflow tests with: dotnet test");
    }
}`}
/>

## Testing with Authentication

<CodeEditor
  initialCode={`using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Xunit;

// Models for authentication
public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}

public class LoginResponse
{
    public string Token { get; set; }
    public DateTime ExpiresAt { get; set; }
}

public class AuthenticatedApiClient : IDisposable
{
    private readonly HttpClient _client;
    private string _authToken;
    
    public AuthenticatedApiClient(string baseUrl)
    {
        _client = new HttpClient
        {
            BaseAddress = new Uri(baseUrl)
        };
    }
    
    // Login and store token
    public async Task<bool> LoginAsync(string username, string password)
    {
        var loginData = new { username, password };
        var json = JsonSerializer.Serialize(loginData);
        var content = new StringContent(json, Encoding.UTF8, "application/json");
        
        var response = await _client.PostAsync("auth/login", content);
        
        if (response.IsSuccessStatusCode)
        {
            var responseJson = await response.Content.ReadAsStringAsync();
            var loginResponse = JsonSerializer.Deserialize<LoginResponse>(responseJson);
            _authToken = loginResponse?.Token;
            
            // Set auth header for future requests
            _client.DefaultRequestHeaders.Authorization = 
                new AuthenticationHeaderValue("Bearer", _authToken);
            
            return true;
        }
        
        return false;
    }
    
    // API Key authentication
    public void SetApiKey(string apiKey)
    {
        _client.DefaultRequestHeaders.Add("X-API-Key", apiKey);
    }
    
    // Basic auth
    public void SetBasicAuth(string username, string password)
    {
        var credentials = Convert.ToBase64String(
            Encoding.ASCII.GetBytes($"{username}:{password}"));
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Basic", credentials);
    }
    
    public async Task<HttpResponseMessage> GetAsync(string endpoint)
    {
        return await _client.GetAsync(endpoint);
    }
    
    public void Dispose() => _client.Dispose();
}

// Example authentication tests (conceptual - requires real auth API)
public class AuthenticationTests
{
    /*
    [Fact]
    public async Task Login_ValidCredentials_ReturnsToken()
    {
        using var client = new AuthenticatedApiClient("https://api.example.com/");
        
        bool success = await client.LoginAsync("testuser", "testpass");
        
        Assert.True(success);
    }
    
    [Fact]
    public async Task ProtectedEndpoint_WithToken_ReturnsData()
    {
        using var client = new AuthenticatedApiClient("https://api.example.com/");
        await client.LoginAsync("testuser", "testpass");
        
        var response = await client.GetAsync("protected/resource");
        
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }
    
    [Fact]
    public async Task ProtectedEndpoint_WithoutToken_Returns401()
    {
        using var client = new AuthenticatedApiClient("https://api.example.com/");
        // Don't login
        
        var response = await client.GetAsync("protected/resource");
        
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
    }
    */
}

class Program
{
    static void Main()
    {
        Console.WriteLine("=== Authentication Patterns ===\\n");
        
        Console.WriteLine("1. Bearer Token:");
        Console.WriteLine("   Authorization: Bearer eyJhbGc...\\n");
        
        Console.WriteLine("2. API Key:");
        Console.WriteLine("   X-API-Key: your-api-key\\n");
        
        Console.WriteLine("3. Basic Auth:");
        Console.WriteLine("   Authorization: Basic base64(user:pass)\\n");
        
        Console.WriteLine("4. OAuth 2.0:");
        Console.WriteLine("   - Get token from auth server");
        Console.WriteLine("   - Include in Authorization header");
    }
}`}
/>

## Error Handling Tests

<CodeEditor
  initialCode={`using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Xunit;

public class ErrorHandlingTests : IDisposable
{
    private readonly JsonPlaceholderClient _client;
    
    public ErrorHandlingTests()
    {
        _client = new JsonPlaceholderClient();
    }
    
    public void Dispose() => _client.Dispose();
    
    // Test 404 Not Found
    [Theory]
    [InlineData("posts/999999")]
    [InlineData("users/999999")]
    [InlineData("comments/999999")]
    public async Task GetNonExistent_ReturnsNotFound(string endpoint)
    {
        var response = await _client.GetAsync<object>(endpoint);
        
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }
    
    // Test invalid endpoint
    [Fact]
    public async Task GetInvalidEndpoint_Returns404()
    {
        var response = await _client.GetAsync<object>("invalid-endpoint");
        
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }
    
    // Test response time
    [Fact]
    public async Task AllEndpoints_RespondWithinTimeout()
    {
        string[] endpoints = { "posts", "users", "comments", "todos" };
        
        foreach (var endpoint in endpoints)
        {
            var response = await _client.GetAsync<object>(endpoint);
            
            Assert.True(response.ResponseTimeMs < 5000,
                $"{endpoint} took {response.ResponseTimeMs}ms");
        }
    }
    
    // Test malformed requests are handled
    [Fact]
    public async Task PostInvalidJson_HandledGracefully()
    {
        // The client should handle this without throwing
        var response = await _client.PostAsync<object>("posts", new { });
        
        // JSONPlaceholder accepts empty objects, but tests the flow
        Assert.True(response.IsSuccess || response.StatusCode == HttpStatusCode.BadRequest);
    }
    
    // Test empty response handling
    [Fact]
    public async Task GetResource_EmptyResponse_Handled()
    {
        var response = await _client.GetAsync<List<object>>("posts?userId=99999");
        
        Assert.True(response.IsSuccess);
        Assert.NotNull(response.Data);
        Assert.Empty(response.Data);  // Should be empty, not null
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Error handling tests ensure robust API testing");
    }
}`}
/>

## Test Configuration and Fixtures

<CodeEditor
  initialCode={`using System;
using System.Threading.Tasks;
using Xunit;

// Shared test context - created once, reused by all tests
public class ApiTestFixture : IAsyncLifetime
{
    public JsonPlaceholderClient Client { get; private set; }
    public int TestUserId { get; private set; }
    public int TestPostId { get; private set; }
    
    public async Task InitializeAsync()
    {
        Console.WriteLine("Setting up test fixture...");
        
        Client = new JsonPlaceholderClient();
        
        // Create test data
        TestUserId = 1;  // Using existing user
        TestPostId = 1;  // Using existing post
        
        // Verify API is accessible
        var response = await Client.GetAsync<object>("posts/1");
        if (!response.IsSuccess)
        {
            throw new Exception("API not accessible - check connection");
        }
        
        Console.WriteLine("Test fixture ready!");
    }
    
    public Task DisposeAsync()
    {
        Console.WriteLine("Cleaning up test fixture...");
        Client?.Dispose();
        return Task.CompletedTask;
    }
}

// Collection that shares the fixture
[CollectionDefinition("Api Tests")]
public class ApiTestCollection : ICollectionFixture<ApiTestFixture>
{
    // No code needed - just defines the collection
}

// Tests that use the shared fixture
[Collection("Api Tests")]
public class SharedFixtureTests
{
    private readonly ApiTestFixture _fixture;
    
    public SharedFixtureTests(ApiTestFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public async Task Test1_UsesSharedClient()
    {
        var response = await _fixture.Client.GetAsync<Post>($"posts/{_fixture.TestPostId}");
        Assert.True(response.IsSuccess);
    }
    
    [Fact]
    public async Task Test2_UsesSharedClient()
    {
        var response = await _fixture.Client.GetAsync<User>($"users/{_fixture.TestUserId}");
        Assert.True(response.IsSuccess);
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Test fixtures share setup across tests");
        Console.WriteLine("- IAsyncLifetime for async setup/teardown");
        Console.WriteLine("- ICollectionFixture for shared resources");
    }
}`}
/>

## Running and Reporting Tests

### Running Tests

```bash
# Run all tests
dotnet test

# Run with verbose output
dotnet test --verbosity detailed

# Run specific test class
dotnet test --filter "FullyQualifiedName~PostApiTests"

# Run specific test
dotnet test --filter "DisplayName~GetAllPosts"

# Generate test results
dotnet test --logger "trx;LogFileName=testresults.trx"

# Generate HTML report (requires tool)
dotnet test --logger "html;LogFileName=testresults.html"
```

### Test Organization Best Practices

<CodeEditor
  initialCode={`using System;

class TestOrganization
{
    static void Main()
    {
        Console.WriteLine("=== Test Organization Best Practices ===\\n");
        
        Console.WriteLine("1. FOLDER STRUCTURE:");
        Console.WriteLine("   Tests/");
        Console.WriteLine("   ‚îú‚îÄ‚îÄ Unit/");
        Console.WriteLine("   ‚îÇ   ‚îú‚îÄ‚îÄ Services/");
        Console.WriteLine("   ‚îÇ   ‚îî‚îÄ‚îÄ Models/");
        Console.WriteLine("   ‚îú‚îÄ‚îÄ Integration/");
        Console.WriteLine("   ‚îÇ   ‚îú‚îÄ‚îÄ Api/");
        Console.WriteLine("   ‚îÇ   ‚îî‚îÄ‚îÄ Database/");
        Console.WriteLine("   ‚îî‚îÄ‚îÄ E2E/");
        Console.WriteLine("       ‚îî‚îÄ‚îÄ Workflows/\\n");
        
        Console.WriteLine("2. NAMING CONVENTIONS:");
        Console.WriteLine("   Class: {Feature}Tests");
        Console.WriteLine("   Method: {Method}_{Scenario}_{Expected}\\n");
        
        Console.WriteLine("3. TEST ATTRIBUTES:");
        Console.WriteLine("   [Fact] - Single test case");
        Console.WriteLine("   [Theory] - Multiple test cases");
        Console.WriteLine("   [Trait] - Categorization");
        Console.WriteLine("   [Collection] - Shared fixtures\\n");
        
        Console.WriteLine("4. TEST CATEGORIES (using Trait):");
        Console.WriteLine("   [Trait(\\"Category\\", \\"Integration\\")]");
        Console.WriteLine("   [Trait(\\"Category\\", \\"Smoke\\")]");
        Console.WriteLine("   [Trait(\\"Priority\\", \\"High\\")]\\n");
        
        Console.WriteLine("5. RUN BY CATEGORY:");
        Console.WriteLine("   dotnet test --filter \\"Category=Smoke\\"");
    }
}`}
/>

## Key Takeaways

- **Structure your tests** with clear folders and naming conventions
- **Create reusable API clients** that handle common operations
- **Use model classes** to deserialize API responses
- **Test all CRUD operations** (Create, Read, Update, Delete)
- **Test related resources** (nested routes, query parameters)
- **Write workflow tests** for end-to-end scenarios
- **Handle authentication** with tokens, API keys, or basic auth
- **Test error scenarios** (404, 401, 500, timeouts)
- **Use fixtures** to share setup across tests
- **Measure response times** for performance testing

## Complete Test Checklist

When testing an API, ensure you cover:

‚úÖ **Happy Path Tests**
- All CRUD operations work
- Valid data returns correct responses
- Response format matches expected schema

‚úÖ **Error Handling**
- Invalid IDs return 404
- Invalid data returns 400/422
- Unauthorized access returns 401
- Missing permissions return 403

‚úÖ **Edge Cases**
- Empty collections
- Maximum/minimum values
- Special characters in data
- Very large payloads

‚úÖ **Integration**
- Related resources work together
- Workflows complete successfully
- Data consistency across operations

‚úÖ **Performance**
- Response times are acceptable
- Concurrent requests work
- Rate limiting is handled

## Congratulations! üéâ

You've completed the comprehensive API Testing course! You now have the skills to:

- ‚úÖ Understand REST APIs and HTTP fundamentals
- ‚úÖ Manually test APIs with Postman and cURL
- ‚úÖ Write automated tests with C# and HttpClient
- ‚úÖ Mock APIs with Moq for isolated testing
- ‚úÖ Test real-world scenarios with authentication
- ‚úÖ Organize and maintain professional test suites

**You're ready to tackle any API testing challenge!** üöÄ
