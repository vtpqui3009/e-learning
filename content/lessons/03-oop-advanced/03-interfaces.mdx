---
title: "Interfaces"
description: "Learn how to define and implement contracts with interfaces"
order: 3
difficulty: "intermediate"
tags: ["oop", "interfaces", "contracts", "polymorphism"]
duration: "30 minutes"
---

# Interfaces in C#

Interfaces define a contract that classes must implement. They specify what a class must do, but not how it does it.

## What is an Interface?

An interface is a completely abstract type that contains only method signatures, properties, events, and indexers - no implementation code.

## Basic Interface Syntax

<CodeEditor 
  initialCode={`using System;

// Interface definition - starts with 'I' by convention
interface IAnimal
{
    // Method signatures (no body)
    void MakeSound();
    void Move();
    
    // Property signature
    string Name { get; set; }
}

// Class implements the interface
class Dog : IAnimal
{
    public string Name { get; set; }
    
    public void MakeSound()
    {
        Console.WriteLine($"{Name} barks: Woof!");
    }
    
    public void Move()
    {
        Console.WriteLine($"{Name} runs on four legs");
    }
}

class Bird : IAnimal
{
    public string Name { get; set; }
    
    public void MakeSound()
    {
        Console.WriteLine($"{Name} chirps: Tweet!");
    }
    
    public void Move()
    {
        Console.WriteLine($"{Name} flies through the air");
    }
}

class Program
{
    static void Main()
    {
        // Can use interface type for variables
        IAnimal dog = new Dog { Name = "Rex" };
        IAnimal bird = new Bird { Name = "Tweety" };
        
        dog.MakeSound();
        dog.Move();
        
        Console.WriteLine();
        
        bird.MakeSound();
        bird.Move();
    }
}`}
/>

## Multiple Interface Implementation

A class can implement multiple interfaces:

<CodeEditor 
  initialCode={`using System;

interface ISwimmable
{
    void Swim();
}

interface IFlyable
{
    void Fly();
}

interface IWalkable
{
    void Walk();
}

// Duck can do it all!
class Duck : ISwimmable, IFlyable, IWalkable
{
    public string Name { get; set; }
    
    public void Swim()
    {
        Console.WriteLine($"{Name} paddles across the water");
    }
    
    public void Fly()
    {
        Console.WriteLine($"{Name} takes off into the sky");
    }
    
    public void Walk()
    {
        Console.WriteLine($"{Name} waddles along");
    }
}

// Fish can only swim
class Fish : ISwimmable
{
    public string Name { get; set; }
    
    public void Swim()
    {
        Console.WriteLine($"{Name} swims gracefully");
    }
}

// Eagle can fly and walk
class Eagle : IFlyable, IWalkable
{
    public string Name { get; set; }
    
    public void Fly()
    {
        Console.WriteLine($"{Name} soars majestically");
    }
    
    public void Walk()
    {
        Console.WriteLine($"{Name} hops around");
    }
}

class Program
{
    static void Main()
    {
        Duck duck = new Duck { Name = "Donald" };
        Fish fish = new Fish { Name = "Nemo" };
        Eagle eagle = new Eagle { Name = "Sam" };
        
        Console.WriteLine("=== Duck ===");
        duck.Swim();
        duck.Fly();
        duck.Walk();
        
        Console.WriteLine("\\n=== Fish ===");
        fish.Swim();
        
        Console.WriteLine("\\n=== Eagle ===");
        eagle.Fly();
        eagle.Walk();
        
        // Using interface type for polymorphism
        Console.WriteLine("\\n=== All Swimmers ===");
        ISwimmable[] swimmers = { duck, fish };
        foreach (var swimmer in swimmers)
        {
            swimmer.Swim();
        }
    }
}`}
/>

## Interface Properties

<CodeEditor 
  initialCode={`using System;

interface IProduct
{
    // Read-write property
    string Name { get; set; }
    decimal Price { get; set; }
    
    // Read-only property
    string Category { get; }
    
    // Calculated property (defined in implementation)
    decimal PriceWithTax { get; }
}

class Book : IProduct
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category => "Books";
    public string Author { get; set; }
    public int Pages { get; set; }
    
    public decimal PriceWithTax => Price * 1.05m;  // 5% tax
}

class Electronics : IProduct
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category => "Electronics";
    public string Brand { get; set; }
    public int WarrantyMonths { get; set; }
    
    public decimal PriceWithTax => Price * 1.10m;  // 10% tax
}

class Program
{
    static void Main()
    {
        IProduct[] products = {
            new Book { Name = "C# Programming", Price = 49.99m, Author = "John Doe", Pages = 500 },
            new Electronics { Name = "Laptop", Price = 999.99m, Brand = "Dell", WarrantyMonths = 24 }
        };
        
        Console.WriteLine("Product Catalog:");
        Console.WriteLine("-----------------");
        
        foreach (var product in products)
        {
            Console.WriteLine($"Name: {product.Name}");
            Console.WriteLine($"Category: {product.Category}");
            Console.WriteLine($"Price: ${'{'}product.Price{'}'}");
            Console.WriteLine($"Price with Tax: ${'{'}product.PriceWithTax{'}'}");
            Console.WriteLine();
        }
    }
}`}
/>

## Interface Inheritance

Interfaces can inherit from other interfaces:

<CodeEditor 
  initialCode={`using System;

// Base interface
interface IEntity
{
    int Id { get; set; }
    DateTime CreatedAt { get; }
}

// Derived interface
interface IAuditable : IEntity
{
    DateTime? ModifiedAt { get; set; }
    string ModifiedBy { get; set; }
}

// Further derived
interface ISoftDeletable : IAuditable
{
    bool IsDeleted { get; set; }
    DateTime? DeletedAt { get; set; }
}

// Class implementing the most derived interface
class Document : ISoftDeletable
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; } = DateTime.Now;
    public DateTime? ModifiedAt { get; set; }
    public string ModifiedBy { get; set; }
    public bool IsDeleted { get; set; }
    public DateTime? DeletedAt { get; set; }
    
    // Additional members
    public string Title { get; set; }
    public string Content { get; set; }
    
    public void SoftDelete(string username)
    {
        IsDeleted = true;
        DeletedAt = DateTime.Now;
        ModifiedAt = DateTime.Now;
        ModifiedBy = username;
    }
}

class Program
{
    static void Main()
    {
        var doc = new Document
        {
            Id = 1,
            Title = "My Document",
            Content = "Hello World"
        };
        
        Console.WriteLine($"Document: {doc.Title}");
        Console.WriteLine($"Created: {doc.CreatedAt}");
        Console.WriteLine($"Is Deleted: {doc.IsDeleted}");
        
        // Modify
        doc.ModifiedAt = DateTime.Now;
        doc.ModifiedBy = "admin";
        Console.WriteLine($"\\nModified by: {doc.ModifiedBy}");
        
        // Soft delete
        doc.SoftDelete("admin");
        Console.WriteLine($"\\nAfter soft delete:");
        Console.WriteLine($"Is Deleted: {doc.IsDeleted}");
        Console.WriteLine($"Deleted At: {doc.DeletedAt}");
    }
}`}
/>

## Default Interface Methods (C# 8+)

Interfaces can have default implementations:

<CodeEditor 
  initialCode={`using System;

interface ILogger
{
    void Log(string message);
    
    // Default implementation
    void LogInfo(string message)
    {
        Log($"[INFO] {message}");
    }
    
    void LogWarning(string message)
    {
        Log($"[WARNING] {message}");
    }
    
    void LogError(string message)
    {
        Log($"[ERROR] {message}");
    }
}

class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {message}");
    }
    
    // Can override default implementation
    public void LogError(string message)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Log($"[ERROR] {message}");
        Console.ResetColor();
    }
}

class FileLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"Writing to file: {message}");
    }
    // Uses default implementations for LogInfo, LogWarning, LogError
}

class Program
{
    static void Main()
    {
        ILogger consoleLogger = new ConsoleLogger();
        ILogger fileLogger = new FileLogger();
        
        Console.WriteLine("=== Console Logger ===");
        consoleLogger.Log("Basic log");
        consoleLogger.LogInfo("Information message");
        consoleLogger.LogWarning("Warning message");
        consoleLogger.LogError("Error message");
        
        Console.WriteLine("\\n=== File Logger ===");
        fileLogger.Log("Basic log");
        fileLogger.LogInfo("Information message");
    }
}`}
/>

## Explicit Interface Implementation

Handle conflicting interface members:

<CodeEditor 
  initialCode={`using System;

interface IPrinter
{
    void Print();
}

interface IScanner
{
    void Scan();
    void Print();  // Same name as IPrinter.Print!
}

class MultiFunctionDevice : IPrinter, IScanner
{
    // Explicit implementation for IPrinter
    void IPrinter.Print()
    {
        Console.WriteLine("Printing document...");
    }
    
    // Explicit implementation for IScanner
    void IScanner.Print()
    {
        Console.WriteLine("Printing scan preview...");
    }
    
    public void Scan()
    {
        Console.WriteLine("Scanning...");
    }
    
    // Regular method accessible directly
    public void PrintAll()
    {
        Console.WriteLine("Printing all documents...");
    }
}

class Program
{
    static void Main()
    {
        MultiFunctionDevice device = new MultiFunctionDevice();
        
        // Regular members accessible directly
        device.Scan();
        device.PrintAll();
        
        // Explicit implementations require casting
        Console.WriteLine("\\nUsing as IPrinter:");
        IPrinter printer = device;
        printer.Print();
        
        Console.WriteLine("\\nUsing as IScanner:");
        IScanner scanner = device;
        scanner.Print();
        
        // device.Print(); // Would not compile - must cast first
    }
}`}
/>

## Dependency Injection Pattern

Using interfaces for loose coupling:

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

// Interface for data access
interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
    IEnumerable<T> GetAll();
}

class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}

// In-memory implementation
class InMemoryUserRepository : IRepository<User>
{
    private List<User> users = new List<User>();
    private int nextId = 1;
    
    public void Add(User item)
    {
        item.Id = nextId++;
        users.Add(item);
        Console.WriteLine($"[Memory] Added user: {item.Name}");
    }
    
    public User GetById(int id)
    {
        return users.Find(u => u.Id == id);
    }
    
    public IEnumerable<User> GetAll()
    {
        return users;
    }
}

// Service depends on interface, not concrete class
class UserService
{
    private readonly IRepository<User> repository;
    
    // Dependency injected via constructor
    public UserService(IRepository<User> repository)
    {
        this.repository = repository;
    }
    
    public void RegisterUser(string name, string email)
    {
        var user = new User { Name = name, Email = email };
        repository.Add(user);
    }
    
    public void ListUsers()
    {
        Console.WriteLine("\\nAll Users:");
        foreach (var user in repository.GetAll())
        {
            Console.WriteLine($"  [{user.Id}] {user.Name} - {user.Email}");
        }
    }
}

class Program
{
    static void Main()
    {
        // Create repository implementation
        IRepository<User> repo = new InMemoryUserRepository();
        
        // Inject dependency into service
        UserService service = new UserService(repo);
        
        // Use the service
        service.RegisterUser("Alice", "alice@example.com");
        service.RegisterUser("Bob", "bob@example.com");
        service.RegisterUser("Charlie", "charlie@example.com");
        
        service.ListUsers();
    }
}`}
/>

## Complete Example: Plugin System

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

// Plugin interface
interface IPlugin
{
    string Name { get; }
    string Version { get; }
    void Execute();
}

// Different plugin implementations
class LoggingPlugin : IPlugin
{
    public string Name => "Logging Plugin";
    public string Version => "1.0.0";
    
    public void Execute()
    {
        Console.WriteLine("  [Log] Recording activity...");
    }
}

class SecurityPlugin : IPlugin
{
    public string Name => "Security Plugin";
    public string Version => "2.1.0";
    
    public void Execute()
    {
        Console.WriteLine("  [Security] Checking permissions...");
    }
}

class AnalyticsPlugin : IPlugin
{
    public string Name => "Analytics Plugin";
    public string Version => "1.5.0";
    
    public void Execute()
    {
        Console.WriteLine("  [Analytics] Collecting metrics...");
    }
}

// Plugin manager
class PluginManager
{
    private List<IPlugin> plugins = new List<IPlugin>();
    
    public void Register(IPlugin plugin)
    {
        plugins.Add(plugin);
        Console.WriteLine($"Registered: {plugin.Name} v{plugin.Version}");
    }
    
    public void ListPlugins()
    {
        Console.WriteLine("\\nInstalled Plugins:");
        foreach (var plugin in plugins)
        {
            Console.WriteLine($"  - {plugin.Name} (v{plugin.Version})");
        }
    }
    
    public void ExecuteAll()
    {
        Console.WriteLine("\\nExecuting all plugins:");
        foreach (var plugin in plugins)
        {
            Console.WriteLine($"{plugin.Name}:");
            plugin.Execute();
        }
    }
}

class Program
{
    static void Main()
    {
        PluginManager manager = new PluginManager();
        
        // Register plugins
        manager.Register(new LoggingPlugin());
        manager.Register(new SecurityPlugin());
        manager.Register(new AnalyticsPlugin());
        
        manager.ListPlugins();
        manager.ExecuteAll();
    }
}`}
/>

## Key Takeaways

- **Interfaces** define contracts without implementation
- Classes can implement **multiple interfaces**
- Interfaces enable **polymorphism** and **loose coupling**
- Use **explicit implementation** to resolve naming conflicts
- **Default methods** (C# 8+) allow backward-compatible interface evolution
- Interfaces are key to **dependency injection**

## Interface vs Abstract Class

| Feature | Interface | Abstract Class |
|---------|-----------|----------------|
| Multiple inheritance | Yes | No |
| Fields | No | Yes |
| Constructors | No | Yes |
| Default implementation | C# 8+ only | Yes |
| Access modifiers | Public by default | Any |

## Best Practices

1. **Keep interfaces focused** - Single Responsibility Principle
2. **Use I prefix** for interface names (IAnimal, ILogger)
3. **Program to interfaces**, not implementations
4. **Prefer composition** over inheritance
5. **Use interfaces for dependencies** to enable testing

## Next Steps

Next lesson: **Abstract Classes** - Learn when to use abstract classes instead of interfaces!
