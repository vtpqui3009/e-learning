---
title: "Abstract Classes"
description: "Learn how to create abstract base classes with shared functionality"
order: 4
difficulty: "intermediate"
tags: ["oop", "abstract", "inheritance", "polymorphism"]
duration: "30 minutes"
---

# Abstract Classes in C#

Abstract classes provide a middle ground between interfaces and regular classes. They can contain both abstract members (that must be overridden) and concrete members (with implementation).

## What is an Abstract Class?

An abstract class is a class that:
- **Cannot be instantiated directly**
- **Can contain abstract methods** (without implementation)
- **Can contain concrete methods** (with implementation)
- **Can have fields, constructors, and properties**

## Basic Abstract Class

<CodeEditor 
  initialCode={`using System;

// Abstract class - cannot create instances directly
abstract class Shape
{
    // Regular property
    public string Color { get; set; }
    
    // Constructor
    protected Shape(string color)
    {
        Color = color;
        Console.WriteLine($"Creating a {color} shape");
    }
    
    // Abstract method - MUST be overridden
    public abstract double GetArea();
    
    // Concrete method - inherited by all derived classes
    public void Display()
    {
        Console.WriteLine($"Shape: {GetType().Name}");
        Console.WriteLine($"Color: {Color}");
        Console.WriteLine($"Area: {GetArea():F2}");
    }
}

class Circle : Shape
{
    public double Radius { get; set; }
    
    public Circle(string color, double radius) : base(color)
    {
        Radius = radius;
    }
    
    // Must implement abstract method
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
}

class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public Rectangle(string color, double width, double height) : base(color)
    {
        Width = width;
        Height = height;
    }
    
    public override double GetArea()
    {
        return Width * Height;
    }
}

class Program
{
    static void Main()
    {
        // Cannot do: Shape shape = new Shape("Red"); // Compile error!
        
        Shape circle = new Circle("Red", 5);
        circle.Display();
        
        Console.WriteLine();
        
        Shape rectangle = new Rectangle("Blue", 10, 5);
        rectangle.Display();
    }
}`}
/>

## Abstract Properties

<CodeEditor 
  initialCode={`using System;

abstract class Employee
{
    public string Name { get; set; }
    public int Id { get; set; }
    
    // Abstract property - derived classes define it
    public abstract decimal Salary { get; }
    
    // Abstract read-write property
    public abstract string Department { get; set; }
    
    protected Employee(int id, string name)
    {
        Id = id;
        Name = name;
    }
    
    public virtual void PrintInfo()
    {
        Console.WriteLine($"ID: {Id}");
        Console.WriteLine($"Name: {Name}");
        Console.WriteLine($"Department: {Department}");
        Console.WriteLine($"Salary: ${'{'}Salary:F2{'}'}");
    }
}

class FullTimeEmployee : Employee
{
    private string department;
    public decimal AnnualSalary { get; set; }
    
    public override decimal Salary => AnnualSalary / 12;
    
    public override string Department
    {
        get => department;
        set => department = value;
    }
    
    public FullTimeEmployee(int id, string name, decimal annualSalary) 
        : base(id, name)
    {
        AnnualSalary = annualSalary;
    }
}

class Contractor : Employee
{
    private string department;
    public decimal HourlyRate { get; set; }
    public int HoursWorked { get; set; }
    
    public override decimal Salary => HourlyRate * HoursWorked;
    
    public override string Department
    {
        get => department;
        set => department = value;
    }
    
    public Contractor(int id, string name, decimal hourlyRate, int hours)
        : base(id, name)
    {
        HourlyRate = hourlyRate;
        HoursWorked = hours;
    }
    
    public override void PrintInfo()
    {
        base.PrintInfo();
        Console.WriteLine($"Hours: {HoursWorked}");
        Console.WriteLine($"Rate: ${'{'}HourlyRate{'}'}/hr");
    }
}

class Program
{
    static void Main()
    {
        Employee[] employees = {
            new FullTimeEmployee(1, "Alice", 72000) { Department = "Engineering" },
            new Contractor(2, "Bob", 75, 160) { Department = "IT" }
        };
        
        foreach (var emp in employees)
        {
            emp.PrintInfo();
            Console.WriteLine();
        }
    }
}`}
/>

## Combining Abstract and Concrete Members

<CodeEditor 
  initialCode={`using System;

abstract class Vehicle
{
    // Fields and properties
    public string Brand { get; set; }
    public string Model { get; set; }
    public int Year { get; set; }
    protected bool isRunning = false;
    
    // Constructor
    protected Vehicle(string brand, string model, int year)
    {
        Brand = brand;
        Model = model;
        Year = year;
    }
    
    // Concrete methods
    public void Start()
    {
        if (!isRunning)
        {
            isRunning = true;
            Console.WriteLine($"{Brand} {Model} started");
            OnStart();  // Call abstract method
        }
    }
    
    public void Stop()
    {
        if (isRunning)
        {
            isRunning = false;
            Console.WriteLine($"{Brand} {Model} stopped");
        }
    }
    
    // Abstract methods - define what, not how
    protected abstract void OnStart();
    public abstract void Drive();
    public abstract int GetMaxSpeed();
}

class Car : Vehicle
{
    public int Doors { get; set; }
    
    public Car(string brand, string model, int year, int doors)
        : base(brand, model, year)
    {
        Doors = doors;
    }
    
    protected override void OnStart()
    {
        Console.WriteLine("  Engine purring smoothly");
    }
    
    public override void Drive()
    {
        if (isRunning)
        {
            Console.WriteLine($"Driving {Brand} {Model} on the road");
        }
        else
        {
            Console.WriteLine("Car is not running!");
        }
    }
    
    public override int GetMaxSpeed() => 200;
}

class Motorcycle : Vehicle
{
    public bool HasSidecar { get; set; }
    
    public Motorcycle(string brand, string model, int year)
        : base(brand, model, year)
    {
    }
    
    protected override void OnStart()
    {
        Console.WriteLine("  Engine roaring to life!");
    }
    
    public override void Drive()
    {
        if (isRunning)
        {
            Console.WriteLine($"Riding {Brand} {Model} on the highway");
        }
        else
        {
            Console.WriteLine("Motorcycle is not running!");
        }
    }
    
    public override int GetMaxSpeed() => 250;
}

class Program
{
    static void Main()
    {
        Vehicle[] vehicles = {
            new Car("Toyota", "Camry", 2022, 4),
            new Motorcycle("Harley", "Davidson", 2023)
        };
        
        foreach (var vehicle in vehicles)
        {
            Console.WriteLine($"\\n=== {vehicle.Brand} {vehicle.Model} ===");
            Console.WriteLine($"Max speed: {vehicle.GetMaxSpeed()} km/h");
            vehicle.Start();
            vehicle.Drive();
            vehicle.Stop();
        }
    }
}`}
/>

## Template Method Pattern

Abstract classes are perfect for template method pattern:

<CodeEditor 
  initialCode={`using System;

abstract class DataProcessor
{
    // Template method - defines the algorithm structure
    public void Process()
    {
        Console.WriteLine("Starting data processing...");
        
        var data = ReadData();
        var processed = ProcessData(data);
        SaveData(processed);
        
        Console.WriteLine("Processing complete!\\n");
    }
    
    // Abstract methods - subclasses define specifics
    protected abstract string ReadData();
    protected abstract string ProcessData(string data);
    protected abstract void SaveData(string data);
}

class CsvProcessor : DataProcessor
{
    protected override string ReadData()
    {
        Console.WriteLine("  Reading CSV file...");
        return "name,age,city\\nJohn,30,NYC\\nJane,25,LA";
    }
    
    protected override string ProcessData(string data)
    {
        Console.WriteLine("  Parsing CSV data...");
        return data.Replace(",", " | ");
    }
    
    protected override void SaveData(string data)
    {
        Console.WriteLine("  Saving to database...");
        Console.WriteLine($"  Data: {data.Split('\\n')[0]}...");
    }
}

class JsonProcessor : DataProcessor
{
    protected override string ReadData()
    {
        Console.WriteLine("  Reading JSON API...");
        return "{ \"users\": [{ \"name\": \"John\" }] }";
    }
    
    protected override string ProcessData(string data)
    {
        Console.WriteLine("  Parsing JSON data...");
        return data.ToUpper();
    }
    
    protected override void SaveData(string data)
    {
        Console.WriteLine("  Sending to message queue...");
    }
}

class Program
{
    static void Main()
    {
        DataProcessor[] processors = {
            new CsvProcessor(),
            new JsonProcessor()
        };
        
        foreach (var processor in processors)
        {
            Console.WriteLine($"=== {processor.GetType().Name} ===");
            processor.Process();
        }
    }
}`}
/>

## Abstract Classes with Interfaces

Classes can inherit from one abstract class AND implement multiple interfaces:

<CodeEditor 
  initialCode={`using System;

// Interface
interface ISerializable
{
    string Serialize();
}

interface IComparable
{
    int CompareTo(object other);
}

// Abstract base class
abstract class GameCharacter
{
    public string Name { get; set; }
    public int Level { get; set; }
    public int Health { get; protected set; }
    
    protected GameCharacter(string name)
    {
        Name = name;
        Level = 1;
        Health = 100;
    }
    
    public abstract void Attack(GameCharacter target);
    public abstract void SpecialAbility();
    
    public virtual void TakeDamage(int damage)
    {
        Health -= damage;
        if (Health < 0) Health = 0;
        Console.WriteLine($"{Name} takes {damage} damage. Health: {Health}");
    }
}

// Implements abstract class AND multiple interfaces
class Warrior : GameCharacter, ISerializable, IComparable
{
    public int Strength { get; set; }
    
    public Warrior(string name, int strength) : base(name)
    {
        Strength = strength;
        Health = 150;  // Warriors have more health
    }
    
    public override void Attack(GameCharacter target)
    {
        int damage = 10 + Strength;
        Console.WriteLine($"{Name} swings sword at {target.Name}!");
        target.TakeDamage(damage);
    }
    
    public override void SpecialAbility()
    {
        Console.WriteLine($"{Name} uses Shield Bash!");
    }
    
    public string Serialize()
    {
        return $"Warrior:{Name},{Level},{Health},{Strength}";
    }
    
    public int CompareTo(object other)
    {
        if (other is GameCharacter gc)
            return this.Level - gc.Level;
        return 0;
    }
}

class Mage : GameCharacter, ISerializable
{
    public int Mana { get; set; }
    
    public Mage(string name, int mana) : base(name)
    {
        Mana = mana;
        Health = 80;  // Mages have less health
    }
    
    public override void Attack(GameCharacter target)
    {
        if (Mana >= 10)
        {
            Mana -= 10;
            Console.WriteLine($"{Name} casts Fireball at {target.Name}!");
            target.TakeDamage(25);
        }
        else
        {
            Console.WriteLine($"{Name} is out of mana!");
        }
    }
    
    public override void SpecialAbility()
    {
        Console.WriteLine($"{Name} casts Teleport!");
    }
    
    public string Serialize()
    {
        return $"Mage:{Name},{Level},{Health},{Mana}";
    }
}

class Program
{
    static void Main()
    {
        Warrior warrior = new Warrior("Conan", 15);
        Mage mage = new Mage("Gandalf", 100);
        
        Console.WriteLine("=== Battle ===\\n");
        
        warrior.Attack(mage);
        mage.Attack(warrior);
        
        Console.WriteLine();
        warrior.SpecialAbility();
        mage.SpecialAbility();
        
        Console.WriteLine("\\n=== Serialization ===");
        Console.WriteLine(warrior.Serialize());
        Console.WriteLine(mage.Serialize());
    }
}`}
/>

## Factory Pattern with Abstract Classes

<CodeEditor 
  initialCode={`using System;

abstract class Document
{
    public string Content { get; set; }
    public DateTime CreatedAt { get; } = DateTime.Now;
    
    public abstract void Open();
    public abstract void Save();
    public abstract void Print();
}

class PdfDocument : Document
{
    public override void Open() => Console.WriteLine("Opening PDF viewer...");
    public override void Save() => Console.WriteLine("Saving as .pdf");
    public override void Print() => Console.WriteLine("Sending PDF to printer...");
}

class WordDocument : Document
{
    public override void Open() => Console.WriteLine("Opening Word processor...");
    public override void Save() => Console.WriteLine("Saving as .docx");
    public override void Print() => Console.WriteLine("Printing Word document...");
}

class SpreadsheetDocument : Document
{
    public override void Open() => Console.WriteLine("Opening spreadsheet app...");
    public override void Save() => Console.WriteLine("Saving as .xlsx");
    public override void Print() => Console.WriteLine("Printing spreadsheet...");
}

// Factory class
static class DocumentFactory
{
    public static Document Create(string type)
    {
        return type.ToLower() switch
        {
            "pdf" => new PdfDocument(),
            "word" => new WordDocument(),
            "excel" or "spreadsheet" => new SpreadsheetDocument(),
            _ => throw new ArgumentException($"Unknown document type: {type}")
        };
    }
}

class Program
{
    static void Main()
    {
        string[] types = { "pdf", "word", "excel" };
        
        foreach (var type in types)
        {
            Console.WriteLine($"\\n=== Creating {type.ToUpper()} ===");
            Document doc = DocumentFactory.Create(type);
            doc.Content = "Hello World";
            doc.Open();
            doc.Save();
            doc.Print();
        }
    }
}`}
/>

## Complete Example: Game Entity System

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

abstract class Entity
{
    private static int nextId = 1;
    
    public int Id { get; }
    public string Name { get; set; }
    public double X { get; set; }
    public double Y { get; set; }
    public bool IsActive { get; set; } = true;
    
    protected Entity(string name)
    {
        Id = nextId++;
        Name = name;
    }
    
    public abstract void Update();
    public abstract void Render();
    
    public void Move(double dx, double dy)
    {
        X += dx;
        Y += dy;
    }
    
    public override string ToString()
    {
        return $"{GetType().Name} '{Name}' at ({X:F1}, {Y:F1})";
    }
}

class Player : Entity
{
    public int Score { get; set; }
    public int Lives { get; set; } = 3;
    
    public Player(string name) : base(name) { }
    
    public override void Update()
    {
        // Simulate player movement
        Console.WriteLine($"[Update] {Name} checking input...");
    }
    
    public override void Render()
    {
        Console.WriteLine($"[Render] Drawing player {Name} at ({X:F0}, {Y:F0})");
        Console.WriteLine($"         Score: {Score}, Lives: {Lives}");
    }
}

class Enemy : Entity
{
    public int Damage { get; set; }
    public double Speed { get; set; }
    
    public Enemy(string name, int damage, double speed) : base(name)
    {
        Damage = damage;
        Speed = speed;
    }
    
    public override void Update()
    {
        // Simple AI: move towards origin
        X -= Speed * 0.1;
        Console.WriteLine($"[Update] {Name} moving, now at ({X:F1}, {Y:F1})");
    }
    
    public override void Render()
    {
        Console.WriteLine($"[Render] Drawing enemy {Name} (DMG: {Damage})");
    }
}

class Collectible : Entity
{
    public int Value { get; set; }
    
    public Collectible(string name, int value) : base(name)
    {
        Value = value;
    }
    
    public override void Update()
    {
        // Collectibles might rotate or bob
        Console.WriteLine($"[Update] {Name} sparkling...");
    }
    
    public override void Render()
    {
        Console.WriteLine($"[Render] Drawing collectible {Name} (Value: {Value})");
    }
}

class GameWorld
{
    private List<Entity> entities = new List<Entity>();
    
    public void Add(Entity entity)
    {
        entities.Add(entity);
    }
    
    public void UpdateAll()
    {
        Console.WriteLine("\\n=== Update Phase ===");
        foreach (var entity in entities)
        {
            if (entity.IsActive)
                entity.Update();
        }
    }
    
    public void RenderAll()
    {
        Console.WriteLine("\\n=== Render Phase ===");
        foreach (var entity in entities)
        {
            if (entity.IsActive)
                entity.Render();
        }
    }
}

class Program
{
    static void Main()
    {
        GameWorld world = new GameWorld();
        
        var player = new Player("Hero") { X = 0, Y = 0 };
        world.Add(player);
        world.Add(new Enemy("Goblin", 10, 2.0) { X = 100, Y = 50 });
        world.Add(new Enemy("Orc", 20, 1.5) { X = 80, Y = 30 });
        world.Add(new Collectible("Gold Coin", 100) { X = 50, Y = 25 });
        
        // Simulate game loop
        for (int frame = 1; frame <= 2; frame++)
        {
            Console.WriteLine($"\\n{'=',-30}");
            Console.WriteLine($"       FRAME {frame}");
            Console.WriteLine($"{'=',-30}");
            
            world.UpdateAll();
            world.RenderAll();
        }
    }
}`}
/>

## Abstract vs Interface

| Feature | Abstract Class | Interface |
|---------|---------------|-----------|
| Multiple inheritance | No | Yes |
| Fields | Yes | No |
| Constructors | Yes | No |
| Access modifiers | Any | Public (default) |
| Implementation | Can have | C# 8+ only |
| When to use | IS-A relationship | CAN-DO relationship |

## Key Takeaways

- **Abstract classes** cannot be instantiated directly
- **Abstract methods** must be overridden by derived classes
- **Concrete methods** provide shared functionality
- Use abstract classes for **IS-A relationships** with shared code
- Combine with interfaces for **maximum flexibility**

## Best Practices

1. **Use abstract classes** when you have shared implementation
2. **Use interfaces** for contracts without implementation
3. **Keep abstract classes focused** on a single responsibility
4. **Consider sealed** for final implementations
5. **Document abstract methods** clearly

## Next Module

You've completed Advanced OOP! Continue to **Delegates and Events** to learn about event-driven programming!
