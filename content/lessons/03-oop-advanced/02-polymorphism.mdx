---
title: "Polymorphism"
description: "Learn how objects can take many forms through polymorphism"
order: 2
difficulty: "intermediate"
tags: ["oop", "polymorphism", "virtual", "override"]
duration: "30 minutes"
---

# Polymorphism in C#

Polymorphism means "many forms." It allows objects of different types to be treated as objects of a common base type, while still behaving according to their actual type.

## What is Polymorphism?

Polymorphism enables you to write code that works with a base class or interface, but actually operates on derived classes with specialized behavior.

## Method Overriding

The foundation of polymorphism - derived classes override base class methods:

<CodeEditor 
  initialCode={`using System;

class Animal
{
    public string Name { get; set; }
    
    // Virtual method - can be overridden
    public virtual void MakeSound()
    {
        Console.WriteLine($"{Name} makes a sound");
    }
    
    public virtual void Move()
    {
        Console.WriteLine($"{Name} moves");
    }
}

class Dog : Animal
{
    // Override the base class method
    public override void MakeSound()
    {
        Console.WriteLine($"{Name} barks: Woof!");
    }
    
    public override void Move()
    {
        Console.WriteLine($"{Name} runs on four legs");
    }
}

class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine($"{Name} meows: Meow!");
    }
    
    public override void Move()
    {
        Console.WriteLine($"{Name} prowls silently");
    }
}

class Bird : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine($"{Name} chirps: Tweet!");
    }
    
    public override void Move()
    {
        Console.WriteLine($"{Name} flies through the air");
    }
}

class Program
{
    static void Main()
    {
        // Polymorphism in action
        Animal[] animals = {
            new Dog { Name = "Rex" },
            new Cat { Name = "Whiskers" },
            new Bird { Name = "Tweety" }
        };
        
        // Same code works for all animal types
        foreach (Animal animal in animals)
        {
            animal.MakeSound();  // Calls the correct override
            animal.Move();
            Console.WriteLine();
        }
    }
}`}
/>

## Virtual and Override Keywords

<CodeEditor 
  initialCode={`using System;

class Shape
{
    public string Color { get; set; }
    
    // Virtual - can be overridden
    public virtual double GetArea()
    {
        return 0;
    }
    
    public virtual void Draw()
    {
        Console.WriteLine($"Drawing a {Color} shape");
    }
}

class Circle : Shape
{
    public double Radius { get; set; }
    
    // Override - replaces base implementation
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} circle with radius {Radius}");
    }
}

class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public override double GetArea()
    {
        return Width * Height;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} rectangle {Width}x{Height}");
    }
}

class Triangle : Shape
{
    public double Base { get; set; }
    public double Height { get; set; }
    
    public override double GetArea()
    {
        return 0.5 * Base * Height;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} triangle");
    }
}

class Program
{
    static void Main()
    {
        Shape[] shapes = {
            new Circle { Color = "Red", Radius = 5 },
            new Rectangle { Color = "Blue", Width = 10, Height = 5 },
            new Triangle { Color = "Green", Base = 8, Height = 6 }
        };
        
        foreach (Shape shape in shapes)
        {
            shape.Draw();
            Console.WriteLine($"  Area: {shape.GetArea():F2}\\n");
        }
        
        // Total area calculation
        double totalArea = 0;
        foreach (Shape shape in shapes)
        {
            totalArea += shape.GetArea();
        }
        Console.WriteLine($"Total area: {totalArea:F2}");
    }
}`}
/>

## Calling Base Class Methods

Use `base` keyword to access the parent class implementation:

<CodeEditor 
  initialCode={`using System;

class Employee
{
    public string Name { get; set; }
    public decimal BaseSalary { get; set; }
    
    public virtual decimal CalculatePay()
    {
        return BaseSalary;
    }
    
    public virtual void PrintDetails()
    {
        Console.WriteLine($"Name: {Name}");
        Console.WriteLine($"Base Salary: ${'{'}BaseSalary{'}'}");
    }
}

class SalesEmployee : Employee
{
    public decimal Commission { get; set; }
    public decimal SalesAmount { get; set; }
    
    public override decimal CalculatePay()
    {
        // Call base implementation, then add commission
        return base.CalculatePay() + (SalesAmount * Commission / 100);
    }
    
    public override void PrintDetails()
    {
        base.PrintDetails();  // Call base to print common info
        Console.WriteLine($"Sales: ${'{'}SalesAmount{'}'}");
        Console.WriteLine($"Commission: {Commission}%");
        Console.WriteLine($"Total Pay: ${'{'}CalculatePay(){'}'}}");
    }
}

class Manager : Employee
{
    public decimal Bonus { get; set; }
    public int TeamSize { get; set; }
    
    public override decimal CalculatePay()
    {
        return base.CalculatePay() + Bonus;
    }
    
    public override void PrintDetails()
    {
        base.PrintDetails();
        Console.WriteLine($"Team Size: {TeamSize}");
        Console.WriteLine($"Bonus: ${'{'}Bonus{'}'}");
        Console.WriteLine($"Total Pay: ${'{'}CalculatePay(){'}'}}");
    }
}

class Program
{
    static void Main()
    {
        Employee[] employees = {
            new Employee { Name = "John", BaseSalary = 3000 },
            new SalesEmployee { Name = "Jane", BaseSalary = 2500, SalesAmount = 50000, Commission = 5 },
            new Manager { Name = "Bob", BaseSalary = 4000, Bonus = 1000, TeamSize = 8 }
        };
        
        foreach (var emp in employees)
        {
            emp.PrintDetails();
            Console.WriteLine();
        }
    }
}`}
/>

## Type Checking and Casting

<CodeEditor 
  initialCode={`using System;

class Vehicle
{
    public string Brand { get; set; }
    public virtual void Start() => Console.WriteLine($"{Brand} starting...");
}

class Car : Vehicle
{
    public int Doors { get; set; }
    public void OpenTrunk() => Console.WriteLine("Opening trunk");
}

class Motorcycle : Vehicle
{
    public bool HasSidecar { get; set; }
    public void DoWheelie() => Console.WriteLine("Doing a wheelie!");
}

class Program
{
    static void Main()
    {
        Vehicle[] vehicles = {
            new Car { Brand = "Toyota", Doors = 4 },
            new Motorcycle { Brand = "Harley", HasSidecar = false },
            new Car { Brand = "Honda", Doors = 2 }
        };
        
        foreach (Vehicle vehicle in vehicles)
        {
            vehicle.Start();
            
            // Type checking with 'is'
            if (vehicle is Car)
            {
                Console.WriteLine("  This is a car");
            }
            else if (vehicle is Motorcycle)
            {
                Console.WriteLine("  This is a motorcycle");
            }
            
            // Pattern matching with 'is' and cast
            if (vehicle is Car car)
            {
                Console.WriteLine($"  Doors: {car.Doors}");
                car.OpenTrunk();
            }
            
            if (vehicle is Motorcycle moto)
            {
                Console.WriteLine($"  Has sidecar: {moto.HasSidecar}");
                moto.DoWheelie();
            }
            
            Console.WriteLine();
        }
        
        // Safe casting with 'as'
        Vehicle v = new Motorcycle { Brand = "Ducati", HasSidecar = true };
        Car carAttempt = v as Car;  // Returns null if cast fails
        
        if (carAttempt == null)
        {
            Console.WriteLine("v is not a Car");
        }
    }
}`}
/>

## Sealed Methods

Prevent further overriding in derived classes:

<CodeEditor 
  initialCode={`using System;

class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("*generic animal sound*");
    }
}

class Dog : Animal
{
    // Sealed prevents further override
    public sealed override void Speak()
    {
        Console.WriteLine("Woof!");
    }
}

class Poodle : Dog
{
    // Cannot override Speak - it's sealed in Dog
    // public override void Speak() { } // Compile error!
    
    public void Trick()
    {
        Console.WriteLine("*does a trick*");
    }
}

class Cat : Animal
{
    // Not sealed, can be overridden
    public override void Speak()
    {
        Console.WriteLine("Meow!");
    }
}

class Kitten : Cat
{
    // Can override because Cat.Speak is not sealed
    public override void Speak()
    {
        Console.WriteLine("Mew!");
    }
}

class Program
{
    static void Main()
    {
        Animal[] animals = {
            new Animal(),
            new Dog(),
            new Poodle(),
            new Cat(),
            new Kitten()
        };
        
        foreach (var animal in animals)
        {
            Console.Write($"{animal.GetType().Name}: ");
            animal.Speak();
        }
    }
}`}
/>

## Polymorphism with Collections

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

abstract class Drawable
{
    public int X { get; set; }
    public int Y { get; set; }
    public abstract void Draw();
}

class Point : Drawable
{
    public override void Draw()
    {
        Console.WriteLine($"Point at ({X}, {Y})");
    }
}

class Line : Drawable
{
    public int EndX { get; set; }
    public int EndY { get; set; }
    
    public override void Draw()
    {
        Console.WriteLine($"Line from ({X}, {Y}) to ({EndX}, {EndY})");
    }
}

class Text : Drawable
{
    public string Content { get; set; }
    
    public override void Draw()
    {
        Console.WriteLine($"Text \"{Content}\" at ({X}, {Y})");
    }
}

class Canvas
{
    private List<Drawable> elements = new List<Drawable>();
    
    public void Add(Drawable element)
    {
        elements.Add(element);
    }
    
    public void DrawAll()
    {
        Console.WriteLine("=== Drawing Canvas ===");
        foreach (var element in elements)
        {
            element.Draw();  // Polymorphic call
        }
    }
    
    public void MoveAll(int dx, int dy)
    {
        foreach (var element in elements)
        {
            element.X += dx;
            element.Y += dy;
        }
        Console.WriteLine($"Moved all elements by ({dx}, {dy})");
    }
}

class Program
{
    static void Main()
    {
        Canvas canvas = new Canvas();
        
        canvas.Add(new Point { X = 10, Y = 20 });
        canvas.Add(new Line { X = 0, Y = 0, EndX = 100, EndY = 100 });
        canvas.Add(new Text { X = 50, Y = 50, Content = "Hello!" });
        canvas.Add(new Point { X = 75, Y = 25 });
        
        canvas.DrawAll();
        
        Console.WriteLine();
        canvas.MoveAll(10, 10);
        
        Console.WriteLine();
        canvas.DrawAll();
    }
}`}
/>

## Real-World Example: Payment Processing

<CodeEditor 
  initialCode={`using System;
using System.Collections.Generic;

abstract class PaymentMethod
{
    public string AccountHolder { get; set; }
    public abstract bool ProcessPayment(decimal amount);
    public abstract void PrintReceipt(decimal amount);
}

class CreditCard : PaymentMethod
{
    public string CardNumber { get; set; }
    public string ExpiryDate { get; set; }
    
    public override bool ProcessPayment(decimal amount)
    {
        // Simulate credit card processing
        Console.WriteLine($"Processing credit card payment of ${'{'}amount{'}'}...");
        Console.WriteLine($"Card: **** **** **** {CardNumber.Substring(CardNumber.Length - 4)}");
        return true;  // Simplified - would check with bank
    }
    
    public override void PrintReceipt(decimal amount)
    {
        Console.WriteLine("--- Credit Card Receipt ---");
        Console.WriteLine($"Account: {AccountHolder}");
        Console.WriteLine($"Card: ****{CardNumber.Substring(CardNumber.Length - 4)}");
        Console.WriteLine($"Amount: ${'{'}amount{'}'}");
        Console.WriteLine("---------------------------");
    }
}

class PayPal : PaymentMethod
{
    public string Email { get; set; }
    
    public override bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing PayPal payment of ${'{'}amount{'}'}...");
        Console.WriteLine($"PayPal account: {Email}");
        return true;
    }
    
    public override void PrintReceipt(decimal amount)
    {
        Console.WriteLine("--- PayPal Receipt ---");
        Console.WriteLine($"Account: {AccountHolder}");
        Console.WriteLine($"Email: {Email}");
        Console.WriteLine($"Amount: ${'{'}amount{'}'}");
        Console.WriteLine("----------------------");
    }
}

class BankTransfer : PaymentMethod
{
    public string BankName { get; set; }
    public string AccountNumber { get; set; }
    
    public override bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing bank transfer of ${'{'}amount{'}'}...");
        Console.WriteLine($"Bank: {BankName}");
        return true;
    }
    
    public override void PrintReceipt(decimal amount)
    {
        Console.WriteLine("--- Bank Transfer Receipt ---");
        Console.WriteLine($"Account: {AccountHolder}");
        Console.WriteLine($"Bank: {BankName}");
        Console.WriteLine($"Amount: ${'{'}amount{'}'}");
        Console.WriteLine("-----------------------------");
    }
}

class PaymentProcessor
{
    public void ProcessOrder(PaymentMethod payment, decimal amount)
    {
        Console.WriteLine($"\\n=== Processing Order: ${'{'}amount{'}'} ===\\n");
        
        if (payment.ProcessPayment(amount))
        {
            Console.WriteLine("\\nPayment successful!\\n");
            payment.PrintReceipt(amount);
        }
        else
        {
            Console.WriteLine("\\nPayment failed!");
        }
    }
}

class Program
{
    static void Main()
    {
        PaymentProcessor processor = new PaymentProcessor();
        
        // Different payment methods, same processing code
        var creditCard = new CreditCard 
        { 
            AccountHolder = "John Doe",
            CardNumber = "1234567890123456",
            ExpiryDate = "12/25"
        };
        
        var paypal = new PayPal
        {
            AccountHolder = "Jane Smith",
            Email = "jane@example.com"
        };
        
        var bankTransfer = new BankTransfer
        {
            AccountHolder = "Bob Wilson",
            BankName = "First National",
            AccountNumber = "9876543210"
        };
        
        processor.ProcessOrder(creditCard, 99.99m);
        processor.ProcessOrder(paypal, 49.99m);
        processor.ProcessOrder(bankTransfer, 199.99m);
    }
}`}
/>

## Key Takeaways

- **Polymorphism** allows treating different types uniformly through a base type
- **virtual** marks methods that can be overridden
- **override** provides a new implementation in derived classes
- **base** keyword accesses the parent class implementation
- **sealed** prevents further overriding
- **Type checking** uses `is` and `as` operators

## Benefits of Polymorphism

1. **Write flexible code** that works with many types
2. **Extensibility** - add new types without changing existing code
3. **Maintainability** - changes in one place affect all derived types
4. **Abstraction** - focus on what, not how

## Next Steps

Next lesson: **Interfaces** - Define contracts that classes must implement!
